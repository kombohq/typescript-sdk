/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type Break = {
  /**
   * End time of the break.
   */
  ended_at: Date;
  /**
   * Whether the break is paid or unpaid.
   */
  paid: boolean;
  /**
   * Start time of the break.
   */
  started_at: Date;
};

export type GetHrisTimesheetsPositiveResponseResult = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The Kombo ID of the employee to which the timesheet belongs. The ID can be used to retrieve the employee from the `get employees` endpoint.
   */
  employee_id: string;
  /**
   * Start time of the shift, converted into UTC time zone.
   */
  started_at: Date | null;
  /**
   * End time of the shift, converted into UTC time zone.
   */
  ended_at: Date | null;
  /**
   * The ISO 8601 numeric UTC offset of the timesheet location in the format Â±HH:MM (e.g., "+02:00", "-05:30"). If null, the original offset information was not available. You can use this to display the right timezone for the timesheet in the UI.
   */
  timezone: string | null;
  /**
   * Payable hours including grace periods - only if available in the HRIS. Won't be calculated through Kombo.
   */
  payable_hours: number | null;
  /**
   * Unpaid break in minutes - will be from the HRIS or calculated by Kombo if we have concrete unpaid break times.
   */
  unpaid_break_minutes: number | null;
  /**
   * Concrete times of the breaks.
   */
  breaks?: Array<Break> | null | undefined;
  /**
   * Approval status of the shift. Can be PENDING, APPROVED, REJECTED, or null.
   */
  approval_status: string | null;
  /**
   * The time when the shift was approved.
   */
  approved_at: Date | null;
  /**
   * Comment on the shift.
   */
  comment: string | null;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
};

export type GetHrisTimesheetsPositiveResponseData = {
  /**
   * Cursor string that can be passed to the `cursor` query parameter to get the next page. If this is `null`, then there are no more pages.
   */
  next: string | null;
  results: Array<GetHrisTimesheetsPositiveResponseResult>;
};

export type GetHrisTimesheetsPositiveResponse = {
  status: "success";
  data: GetHrisTimesheetsPositiveResponseData;
};

/** @internal */
export const Break$inboundSchema: z.ZodType<Break, z.ZodTypeDef, unknown> = z
  .object({
    ended_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
    paid: z.boolean(),
    started_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
  });

/** @internal */
export type Break$Outbound = {
  ended_at: string;
  paid: boolean;
  started_at: string;
};

/** @internal */
export const Break$outboundSchema: z.ZodType<
  Break$Outbound,
  z.ZodTypeDef,
  Break
> = z.object({
  ended_at: z.date().transform(v => v.toISOString()),
  paid: z.boolean(),
  started_at: z.date().transform(v => v.toISOString()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Break$ {
  /** @deprecated use `Break$inboundSchema` instead. */
  export const inboundSchema = Break$inboundSchema;
  /** @deprecated use `Break$outboundSchema` instead. */
  export const outboundSchema = Break$outboundSchema;
  /** @deprecated use `Break$Outbound` instead. */
  export type Outbound = Break$Outbound;
}

export function breakToJSON(value: Break): string {
  return JSON.stringify(Break$outboundSchema.parse(value));
}

export function breakFromJSON(
  jsonString: string,
): SafeParseResult<Break, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Break$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Break' from JSON`,
  );
}

/** @internal */
export const GetHrisTimesheetsPositiveResponseResult$inboundSchema: z.ZodType<
  GetHrisTimesheetsPositiveResponseResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  started_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  ended_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  timezone: z.nullable(z.string()),
  payable_hours: z.nullable(z.number()),
  unpaid_break_minutes: z.nullable(z.number()),
  breaks: z.nullable(z.array(z.lazy(() => Break$inboundSchema))).optional(),
  approval_status: z.nullable(z.string()),
  approved_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  comment: z.nullable(z.string()),
  custom_fields: z.nullable(z.record(z.any())),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
});

/** @internal */
export type GetHrisTimesheetsPositiveResponseResult$Outbound = {
  id: string;
  remote_id: string | null;
  employee_id: string;
  started_at: string | null;
  ended_at: string | null;
  timezone: string | null;
  payable_hours: number | null;
  unpaid_break_minutes: number | null;
  breaks?: Array<Break$Outbound> | null | undefined;
  approval_status: string | null;
  approved_at: string | null;
  comment: string | null;
  custom_fields: { [k: string]: any } | null;
  changed_at: string;
  remote_deleted_at: string | null;
};

/** @internal */
export const GetHrisTimesheetsPositiveResponseResult$outboundSchema: z.ZodType<
  GetHrisTimesheetsPositiveResponseResult$Outbound,
  z.ZodTypeDef,
  GetHrisTimesheetsPositiveResponseResult
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  started_at: z.nullable(z.date().transform(v => v.toISOString())),
  ended_at: z.nullable(z.date().transform(v => v.toISOString())),
  timezone: z.nullable(z.string()),
  payable_hours: z.nullable(z.number()),
  unpaid_break_minutes: z.nullable(z.number()),
  breaks: z.nullable(z.array(z.lazy(() => Break$outboundSchema))).optional(),
  approval_status: z.nullable(z.string()),
  approved_at: z.nullable(z.date().transform(v => v.toISOString())),
  comment: z.nullable(z.string()),
  custom_fields: z.nullable(z.record(z.any())),
  changed_at: z.date().transform(v => v.toISOString()),
  remote_deleted_at: z.nullable(z.date().transform(v => v.toISOString())),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisTimesheetsPositiveResponseResult$ {
  /** @deprecated use `GetHrisTimesheetsPositiveResponseResult$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisTimesheetsPositiveResponseResult$inboundSchema;
  /** @deprecated use `GetHrisTimesheetsPositiveResponseResult$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisTimesheetsPositiveResponseResult$outboundSchema;
  /** @deprecated use `GetHrisTimesheetsPositiveResponseResult$Outbound` instead. */
  export type Outbound = GetHrisTimesheetsPositiveResponseResult$Outbound;
}

export function getHrisTimesheetsPositiveResponseResultToJSON(
  getHrisTimesheetsPositiveResponseResult:
    GetHrisTimesheetsPositiveResponseResult,
): string {
  return JSON.stringify(
    GetHrisTimesheetsPositiveResponseResult$outboundSchema.parse(
      getHrisTimesheetsPositiveResponseResult,
    ),
  );
}

export function getHrisTimesheetsPositiveResponseResultFromJSON(
  jsonString: string,
): SafeParseResult<
  GetHrisTimesheetsPositiveResponseResult,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetHrisTimesheetsPositiveResponseResult$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetHrisTimesheetsPositiveResponseResult' from JSON`,
  );
}

/** @internal */
export const GetHrisTimesheetsPositiveResponseData$inboundSchema: z.ZodType<
  GetHrisTimesheetsPositiveResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetHrisTimesheetsPositiveResponseResult$inboundSchema),
  ),
});

/** @internal */
export type GetHrisTimesheetsPositiveResponseData$Outbound = {
  next: string | null;
  results: Array<GetHrisTimesheetsPositiveResponseResult$Outbound>;
};

/** @internal */
export const GetHrisTimesheetsPositiveResponseData$outboundSchema: z.ZodType<
  GetHrisTimesheetsPositiveResponseData$Outbound,
  z.ZodTypeDef,
  GetHrisTimesheetsPositiveResponseData
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetHrisTimesheetsPositiveResponseResult$outboundSchema),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisTimesheetsPositiveResponseData$ {
  /** @deprecated use `GetHrisTimesheetsPositiveResponseData$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisTimesheetsPositiveResponseData$inboundSchema;
  /** @deprecated use `GetHrisTimesheetsPositiveResponseData$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisTimesheetsPositiveResponseData$outboundSchema;
  /** @deprecated use `GetHrisTimesheetsPositiveResponseData$Outbound` instead. */
  export type Outbound = GetHrisTimesheetsPositiveResponseData$Outbound;
}

export function getHrisTimesheetsPositiveResponseDataToJSON(
  getHrisTimesheetsPositiveResponseData: GetHrisTimesheetsPositiveResponseData,
): string {
  return JSON.stringify(
    GetHrisTimesheetsPositiveResponseData$outboundSchema.parse(
      getHrisTimesheetsPositiveResponseData,
    ),
  );
}

export function getHrisTimesheetsPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisTimesheetsPositiveResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetHrisTimesheetsPositiveResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisTimesheetsPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetHrisTimesheetsPositiveResponse$inboundSchema: z.ZodType<
  GetHrisTimesheetsPositiveResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetHrisTimesheetsPositiveResponseData$inboundSchema),
});

/** @internal */
export type GetHrisTimesheetsPositiveResponse$Outbound = {
  status: "success";
  data: GetHrisTimesheetsPositiveResponseData$Outbound;
};

/** @internal */
export const GetHrisTimesheetsPositiveResponse$outboundSchema: z.ZodType<
  GetHrisTimesheetsPositiveResponse$Outbound,
  z.ZodTypeDef,
  GetHrisTimesheetsPositiveResponse
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetHrisTimesheetsPositiveResponseData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisTimesheetsPositiveResponse$ {
  /** @deprecated use `GetHrisTimesheetsPositiveResponse$inboundSchema` instead. */
  export const inboundSchema = GetHrisTimesheetsPositiveResponse$inboundSchema;
  /** @deprecated use `GetHrisTimesheetsPositiveResponse$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisTimesheetsPositiveResponse$outboundSchema;
  /** @deprecated use `GetHrisTimesheetsPositiveResponse$Outbound` instead. */
  export type Outbound = GetHrisTimesheetsPositiveResponse$Outbound;
}

export function getHrisTimesheetsPositiveResponseToJSON(
  getHrisTimesheetsPositiveResponse: GetHrisTimesheetsPositiveResponse,
): string {
  return JSON.stringify(
    GetHrisTimesheetsPositiveResponse$outboundSchema.parse(
      getHrisTimesheetsPositiveResponse,
    ),
  );
}

export function getHrisTimesheetsPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisTimesheetsPositiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetHrisTimesheetsPositiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisTimesheetsPositiveResponse' from JSON`,
  );
}
