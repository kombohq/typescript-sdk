/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const GetAtsJobsPositiveResponseEmploymentType = {
  FullTime: "FULL_TIME",
  PartTime: "PART_TIME",
  Contract: "CONTRACT",
  Seasonal: "SEASONAL",
  Internship: "INTERNSHIP",
} as const;
export type GetAtsJobsPositiveResponseEmploymentType = OpenEnum<
  typeof GetAtsJobsPositiveResponseEmploymentType
>;

export const GetAtsJobsPositiveResponseStatus = {
  Open: "OPEN",
  Closed: "CLOSED",
  Draft: "DRAFT",
  Archived: "ARCHIVED",
} as const;
export type GetAtsJobsPositiveResponseStatus = OpenEnum<
  typeof GetAtsJobsPositiveResponseStatus
>;

export const Visibility = {
  Public: "PUBLIC",
  Internal: "INTERNAL",
  Unlisted: "UNLISTED",
  Confidential: "CONFIDENTIAL",
} as const;
export type Visibility = OpenEnum<typeof Visibility>;

export const RemoteWorkStatus = {
  Remote: "REMOTE",
  Hybrid: "HYBRID",
  Temporary: "TEMPORARY",
  OnSite: "ON_SITE",
} as const;
export type RemoteWorkStatus = OpenEnum<typeof RemoteWorkStatus>;

export const SalaryPeriod = {
  Year: "YEAR",
  Month: "MONTH",
  TwoWeeks: "TWO_WEEKS",
  Week: "WEEK",
  Day: "DAY",
  Hour: "HOUR",
} as const;
export type SalaryPeriod = OpenEnum<typeof SalaryPeriod>;

/**
 * The location of the listed job.
 */
export type GetAtsJobsPositiveResponseLocation = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type Stage = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The application stage name. For example, "Initial Screening".
   */
  name: string | null;
  /**
   * Numeric index following the order of the stages if they are ordered in the underlying tool.
   */
  index?: number | null | undefined;
};

export type FormatUnknown = {
  /**
   * We pass the original question data along so you can handle it.
   */
  raw_question?: any | undefined;
  /**
   * When we're not able to map a specific question type yet, we will return this type. Every `UNKNOWN` question will also be parsed and unified by us at some point.
   */
  type: "UNKNOWN";
};

export type FormatInformation = {
  /**
   * This is just a text block.
   */
  type: "INFORMATION";
};

export type Option2 = {
  /**
   * The Kombo ID of this question option. Use this ID to specify the answer to this question.
   */
  id: string;
  /**
   * ID in the connected ATS. This might be null as some systems only use the name to identify the option.
   */
  remote_id?: string | null | undefined;
  /**
   * Content of the question option.
   */
  name: string;
};

export type FormatMultiSelect = {
  options: Array<Option2>;
  type: "MULTI_SELECT";
};

export type FormatDate = {
  type: "DATE";
};

export type FormatBoolean = {
  type: "BOOLEAN";
};

export const DisplayType3 = {
  Dropdown: "DROPDOWN",
  Radio: "RADIO",
} as const;
export type DisplayType3 = ClosedEnum<typeof DisplayType3>;

export type Option1 = {
  /**
   * The Kombo ID of this question option. Use this ID to specify the answer to this question.
   */
  id: string;
  /**
   * ID in the connected ATS. This might be null as some systems only use the name to identify the option.
   */
  remote_id?: string | null | undefined;
  /**
   * Content of the question option.
   */
  name: string;
};

export type FormatSingleSelect = {
  display_type?: DisplayType3 | null | undefined;
  options: Array<Option1>;
  type: "SINGLE_SELECT";
};

export type FormatFile = {
  accepted_mime_types?: Array<string> | null | undefined;
  max_file_size_bytes?: number | null | undefined;
  type: "FILE";
};

export const DisplayType2 = {
  Slider: "SLIDER",
  Field: "FIELD",
} as const;
export type DisplayType2 = ClosedEnum<typeof DisplayType2>;

export type FormatNumber = {
  display_type?: DisplayType2 | null | undefined;
  max?: number | null | undefined;
  min?: number | null | undefined;
  type: "NUMBER";
};

/**
 * If unavailable, we recommend displaying a single-line input.
 */
export const DisplayType1 = {
  SingleLine: "SINGLE_LINE",
  MultiLine: "MULTI_LINE",
  Email: "EMAIL",
  Url: "URL",
} as const;
/**
 * If unavailable, we recommend displaying a single-line input.
 */
export type DisplayType1 = ClosedEnum<typeof DisplayType1>;

export type FormatText = {
  /**
   * If unavailable, we recommend displaying a single-line input.
   */
  display_type?: DisplayType1 | null | undefined;
  max_length?: number | null | undefined;
  type: "TEXT";
};

export type Format =
  | FormatSingleSelect
  | FormatMultiSelect
  | FormatText
  | FormatNumber
  | FormatFile
  | FormatBoolean
  | FormatDate
  | FormatInformation
  | FormatUnknown;

/**
 * The category of the screening question (default `null`). "EEO" questions are related to Equal Employment Opportunity (e.g. "What is your veteran status?"), while "DEMOGRAPHIC" questions are for other diversity and demographic data collection.
 */
export const GetAtsJobsPositiveResponseCategory = {
  Eeo: "EEO",
  Demographic: "DEMOGRAPHIC",
} as const;
/**
 * The category of the screening question (default `null`). "EEO" questions are related to Equal Employment Opportunity (e.g. "What is your veteran status?"), while "DEMOGRAPHIC" questions are for other diversity and demographic data collection.
 */
export type GetAtsJobsPositiveResponseCategory = ClosedEnum<
  typeof GetAtsJobsPositiveResponseCategory
>;

/**
 * Where the screening question specified by `precondition_question_id` is of type `MULTI_SELECT` or `SINGLE_SELECT`, this is an array of Kombo IDs describing the valid options. If the question is of type `BOOLEAN`, this is an array containing either `true` or `false`.
 */
export type PreconditionOptions = Array<string> | Array<boolean>;

export type ScreeningQuestion = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  title: string | null;
  /**
   * Additional instructions or context. Typically a short sentence, but sometimes a long detailed description (e.g., for EEO questions). May include HTML for extra formatting.
   */
  description: string | null;
  format?:
    | FormatSingleSelect
    | FormatMultiSelect
    | FormatText
    | FormatNumber
    | FormatFile
    | FormatBoolean
    | FormatDate
    | FormatInformation
    | FormatUnknown
    | null
    | undefined;
  /**
   * The category of the screening question (default `null`). "EEO" questions are related to Equal Employment Opportunity (e.g. "What is your veteran status?"), while "DEMOGRAPHIC" questions are for other diversity and demographic data collection.
   */
  category: GetAtsJobsPositiveResponseCategory | null;
  index?: number | null | undefined;
  required: boolean | null;
  /**
   * The Kombo ID of another screening question. Only display this question if the specified "precondition question" is answered with one of the values in `precondition_options`.
   */
  precondition_question_id?: string | null | undefined;
  /**
   * Where the screening question specified by `precondition_question_id` is of type `MULTI_SELECT` or `SINGLE_SELECT`, this is an array of Kombo IDs describing the valid options. If the question is of type `BOOLEAN`, this is an array containing either `true` or `false`.
   */
  precondition_options?: Array<string> | Array<boolean> | null | undefined;
};

/**
 * The job posting’s current status.
 */
export const JobPostingStatus = {
  Active: "ACTIVE",
  Inactive: "INACTIVE",
  Draft: "DRAFT",
} as const;
/**
 * The job posting’s current status.
 */
export type JobPostingStatus = ClosedEnum<typeof JobPostingStatus>;

export const JobPostingVisibility = {
  Public: "PUBLIC",
  Internal: "INTERNAL",
  Unlisted: "UNLISTED",
} as const;
export type JobPostingVisibility = ClosedEnum<typeof JobPostingVisibility>;

export type JobPosting = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The job posting’s title.
   */
  title: string | null;
  /**
   * The job posting’s description in HTML format.
   */
  description_html: string | null;
  /**
   * The job posting’s current status.
   */
  status: JobPostingStatus | null;
  visibility: JobPostingVisibility | null;
  /**
   * The public URL to the job posting on the ATS platform.
   */
  url: string | null;
};

export const GetAtsJobsPositiveResponseHiringTeamRole = {
  Recruiter: "RECRUITER",
  HiringManager: "HIRING_MANAGER",
} as const;
export type GetAtsJobsPositiveResponseHiringTeamRole = ClosedEnum<
  typeof GetAtsJobsPositiveResponseHiringTeamRole
>;

export type GetAtsJobsPositiveResponseHiringTeam = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * First name of the user.
   */
  first_name: string | null;
  /**
   * Last name of the user.
   */
  last_name: string | null;
  /**
   * Email of the user. If the email address is invalid, it will be set to null.
   */
  email?: string | null | undefined;
  /**
   * Array of the roles of the user for this specific job. Currently only `RECRUITER` and `HIRING_MANAGER` are mapped into our unified schema.
   */
  hiring_team_roles: Array<GetAtsJobsPositiveResponseHiringTeamRole>;
};

export type GetAtsJobsPositiveResponseResult = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * Title of the job.
   */
  name: string | null;
  /**
   * The human readable job code. Some systems expose this as the Requisition Code/ID.
   */
  job_code: string | null;
  /**
   * Description of the job. This field is usually returned as HTML.
   */
  description: string | null;
  /**
   * **(⚠️ Deprecated)** It makes more sense to store the visibility of a job in an enum. Therefore, we introduced the `visibility` enum on jobs.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  confidential: boolean | null;
  /**
   * The number of hours per week an employee is expected to work.
   */
  weekly_hours: number | null;
  /**
   * The type of employment contract. In rare cases where can't find a clear mapping, the original string is passed through.
   */
  employment_type?: GetAtsJobsPositiveResponseEmploymentType | null | undefined;
  /**
   * The job's current status.
   *
   * @remarks
   *
   * *Note: For any checks (e.g., "can we publish this job?"), always evaluate both `status` and `visibility`. For example, a job can be `status=OPEN` with `visibility=INTERNAL`, meaning only existing employees can apply.*
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  status?: GetAtsJobsPositiveResponseStatus | null | undefined;
  /**
   * Describes the visibility of the job:
   *
   * @remarks
   *
   * - `PUBLIC`: visible to everyone, published on a job board
   * - `INTERNAL`: only visible to employees of the company itself
   * - `UNLISTED`: anyone can apply but only if they have the link to it
   * - `CONFIDENTIAL`: nobody can apply and it's only visible in the ATS to people who were invited to it
   *
   * *Note: For any checks (e.g., "can we publish this job?"), always evaluate both `status` and `visibility`.*
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  visibility?: Visibility | null | undefined;
  /**
   * The category of the job (often the job industry). The original string is passed through, for example "Information Technology", "Quality Assurance", "Marketing".
   */
  category: string | null;
  /**
   * The internal department or team the job belongs to. The original string is passed through, for example "IT/Operations", "Engineering - Platform", "Customer Success".
   */
  department: string | null;
  /**
   * The public job posting URL of the ATS itself. This can be used by external job boards to redirect applicants.
   */
  post_url: string | null;
  /**
   * The role's seniority or experience level. The original string is passed through, for example "Mid-Senior Level", "5+ years", "Associate", "IC3".
   */
  experience_level: string | null;
  /**
   * Defines if the job supports remote work and if so, to what extent.
   */
  remote_work_status?: RemoteWorkStatus | null | undefined;
  /**
   * The salary amount in the given currency.
   */
  salary_amount: number | null;
  /**
   * The lower bound of the salary range.
   */
  salary_amount_from: number | null;
  /**
   * The upper bound of the salary range.
   */
  salary_amount_to: number | null;
  /**
   * Salary currency usually returned in [ISO 4217 currency codes](https://www.iso.org/iso-4217-currency-codes.html).
   */
  salary_currency: string | null;
  /**
   * The period of time over which the salary amount is paid (not equal to the pay frequency). In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  salary_period?: SalaryPeriod | null | undefined;
  /**
   * The location of the listed job.
   */
  location?: GetAtsJobsPositiveResponseLocation | null | undefined;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
  /**
   * URL to the job posting in the source ATS system.
   */
  remote_url: string | null;
  /**
   * YYYY-MM-DDTHH:mm:ss.sssZ
   */
  opened_at: Date | null;
  /**
   * The date the job closed or is scheduled to close. A future value typically indicates the job remains open for applications until that date.
   *
   * @remarks
   *
   * Please use the `status` and `visibility` fields to determine if a job can be published.
   */
  closed_at: Date | null;
  /**
   * The date and time the object was created in the remote system.
   */
  remote_created_at: Date | null;
  /**
   * A timestamp retrieved from the remote system, describing when the resource was last updated.
   */
  remote_updated_at: Date | null;
  /**
   * **(⚠️ Deprecated)** The user ID of the contact person for this job. We strongly recommend using the new `hiring_team` property instead as it provides more complete and accurate information about the ATS users connected to a job.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact_id: string | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * Application stages a candidate can be in for this particular job.
   */
  stages: Array<Stage>;
  screening_questions: Array<ScreeningQuestion>;
  job_postings: Array<JobPosting>;
  /**
   * The hiring team allows you to sync users into your system who can access the job and its applications.
   */
  hiring_team: Array<GetAtsJobsPositiveResponseHiringTeam>;
};

export type GetAtsJobsPositiveResponseData = {
  /**
   * Cursor string that can be passed to the `cursor` query parameter to get the next page. If this is `null`, then there are no more pages.
   */
  next: string | null;
  results: Array<GetAtsJobsPositiveResponseResult>;
};

export type GetAtsJobsPositiveResponse = {
  status: "success";
  data: GetAtsJobsPositiveResponseData;
};

/** @internal */
export const GetAtsJobsPositiveResponseEmploymentType$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseEmploymentType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetAtsJobsPositiveResponseEmploymentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetAtsJobsPositiveResponseEmploymentType$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseEmploymentType,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponseEmploymentType
> = z.union([
  z.nativeEnum(GetAtsJobsPositiveResponseEmploymentType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseEmploymentType$ {
  /** @deprecated use `GetAtsJobsPositiveResponseEmploymentType$inboundSchema` instead. */
  export const inboundSchema =
    GetAtsJobsPositiveResponseEmploymentType$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseEmploymentType$outboundSchema` instead. */
  export const outboundSchema =
    GetAtsJobsPositiveResponseEmploymentType$outboundSchema;
}

/** @internal */
export const GetAtsJobsPositiveResponseStatus$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetAtsJobsPositiveResponseStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetAtsJobsPositiveResponseStatus$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseStatus,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponseStatus
> = z.union([
  z.nativeEnum(GetAtsJobsPositiveResponseStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseStatus$ {
  /** @deprecated use `GetAtsJobsPositiveResponseStatus$inboundSchema` instead. */
  export const inboundSchema = GetAtsJobsPositiveResponseStatus$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseStatus$outboundSchema` instead. */
  export const outboundSchema = GetAtsJobsPositiveResponseStatus$outboundSchema;
}

/** @internal */
export const Visibility$inboundSchema: z.ZodType<
  Visibility,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Visibility),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Visibility$outboundSchema: z.ZodType<
  Visibility,
  z.ZodTypeDef,
  Visibility
> = z.union([
  z.nativeEnum(Visibility),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Visibility$ {
  /** @deprecated use `Visibility$inboundSchema` instead. */
  export const inboundSchema = Visibility$inboundSchema;
  /** @deprecated use `Visibility$outboundSchema` instead. */
  export const outboundSchema = Visibility$outboundSchema;
}

/** @internal */
export const RemoteWorkStatus$inboundSchema: z.ZodType<
  RemoteWorkStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RemoteWorkStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RemoteWorkStatus$outboundSchema: z.ZodType<
  RemoteWorkStatus,
  z.ZodTypeDef,
  RemoteWorkStatus
> = z.union([
  z.nativeEnum(RemoteWorkStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RemoteWorkStatus$ {
  /** @deprecated use `RemoteWorkStatus$inboundSchema` instead. */
  export const inboundSchema = RemoteWorkStatus$inboundSchema;
  /** @deprecated use `RemoteWorkStatus$outboundSchema` instead. */
  export const outboundSchema = RemoteWorkStatus$outboundSchema;
}

/** @internal */
export const SalaryPeriod$inboundSchema: z.ZodType<
  SalaryPeriod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SalaryPeriod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SalaryPeriod$outboundSchema: z.ZodType<
  SalaryPeriod,
  z.ZodTypeDef,
  SalaryPeriod
> = z.union([
  z.nativeEnum(SalaryPeriod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SalaryPeriod$ {
  /** @deprecated use `SalaryPeriod$inboundSchema` instead. */
  export const inboundSchema = SalaryPeriod$inboundSchema;
  /** @deprecated use `SalaryPeriod$outboundSchema` instead. */
  export const outboundSchema = SalaryPeriod$outboundSchema;
}

/** @internal */
export const GetAtsJobsPositiveResponseLocation$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/** @internal */
export type GetAtsJobsPositiveResponseLocation$Outbound = {
  city?: string | null | undefined;
  country?: string | null | undefined;
  raw?: string | null | undefined;
  state?: string | null | undefined;
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

/** @internal */
export const GetAtsJobsPositiveResponseLocation$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseLocation$Outbound,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponseLocation
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseLocation$ {
  /** @deprecated use `GetAtsJobsPositiveResponseLocation$inboundSchema` instead. */
  export const inboundSchema = GetAtsJobsPositiveResponseLocation$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseLocation$outboundSchema` instead. */
  export const outboundSchema =
    GetAtsJobsPositiveResponseLocation$outboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseLocation$Outbound` instead. */
  export type Outbound = GetAtsJobsPositiveResponseLocation$Outbound;
}

export function getAtsJobsPositiveResponseLocationToJSON(
  getAtsJobsPositiveResponseLocation: GetAtsJobsPositiveResponseLocation,
): string {
  return JSON.stringify(
    GetAtsJobsPositiveResponseLocation$outboundSchema.parse(
      getAtsJobsPositiveResponseLocation,
    ),
  );
}

export function getAtsJobsPositiveResponseLocationFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseLocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsJobsPositiveResponseLocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseLocation' from JSON`,
  );
}

/** @internal */
export const Stage$inboundSchema: z.ZodType<Stage, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    remote_id: z.nullable(z.string()),
    name: z.nullable(z.string()),
    index: z.nullable(z.number().int()).optional(),
  });

/** @internal */
export type Stage$Outbound = {
  id: string;
  remote_id: string | null;
  name: string | null;
  index?: number | null | undefined;
};

/** @internal */
export const Stage$outboundSchema: z.ZodType<
  Stage$Outbound,
  z.ZodTypeDef,
  Stage
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  index: z.nullable(z.number().int()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stage$ {
  /** @deprecated use `Stage$inboundSchema` instead. */
  export const inboundSchema = Stage$inboundSchema;
  /** @deprecated use `Stage$outboundSchema` instead. */
  export const outboundSchema = Stage$outboundSchema;
  /** @deprecated use `Stage$Outbound` instead. */
  export type Outbound = Stage$Outbound;
}

export function stageToJSON(stage: Stage): string {
  return JSON.stringify(Stage$outboundSchema.parse(stage));
}

export function stageFromJSON(
  jsonString: string,
): SafeParseResult<Stage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stage' from JSON`,
  );
}

/** @internal */
export const FormatUnknown$inboundSchema: z.ZodType<
  FormatUnknown,
  z.ZodTypeDef,
  unknown
> = z.object({
  raw_question: z.any().optional(),
  type: z.literal("UNKNOWN"),
});

/** @internal */
export type FormatUnknown$Outbound = {
  raw_question?: any | undefined;
  type: "UNKNOWN";
};

/** @internal */
export const FormatUnknown$outboundSchema: z.ZodType<
  FormatUnknown$Outbound,
  z.ZodTypeDef,
  FormatUnknown
> = z.object({
  raw_question: z.any().optional(),
  type: z.literal("UNKNOWN"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatUnknown$ {
  /** @deprecated use `FormatUnknown$inboundSchema` instead. */
  export const inboundSchema = FormatUnknown$inboundSchema;
  /** @deprecated use `FormatUnknown$outboundSchema` instead. */
  export const outboundSchema = FormatUnknown$outboundSchema;
  /** @deprecated use `FormatUnknown$Outbound` instead. */
  export type Outbound = FormatUnknown$Outbound;
}

export function formatUnknownToJSON(formatUnknown: FormatUnknown): string {
  return JSON.stringify(FormatUnknown$outboundSchema.parse(formatUnknown));
}

export function formatUnknownFromJSON(
  jsonString: string,
): SafeParseResult<FormatUnknown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatUnknown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatUnknown' from JSON`,
  );
}

/** @internal */
export const FormatInformation$inboundSchema: z.ZodType<
  FormatInformation,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("INFORMATION"),
});

/** @internal */
export type FormatInformation$Outbound = {
  type: "INFORMATION";
};

/** @internal */
export const FormatInformation$outboundSchema: z.ZodType<
  FormatInformation$Outbound,
  z.ZodTypeDef,
  FormatInformation
> = z.object({
  type: z.literal("INFORMATION"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatInformation$ {
  /** @deprecated use `FormatInformation$inboundSchema` instead. */
  export const inboundSchema = FormatInformation$inboundSchema;
  /** @deprecated use `FormatInformation$outboundSchema` instead. */
  export const outboundSchema = FormatInformation$outboundSchema;
  /** @deprecated use `FormatInformation$Outbound` instead. */
  export type Outbound = FormatInformation$Outbound;
}

export function formatInformationToJSON(
  formatInformation: FormatInformation,
): string {
  return JSON.stringify(
    FormatInformation$outboundSchema.parse(formatInformation),
  );
}

export function formatInformationFromJSON(
  jsonString: string,
): SafeParseResult<FormatInformation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatInformation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatInformation' from JSON`,
  );
}

/** @internal */
export const Option2$inboundSchema: z.ZodType<Option2, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    remote_id: z.nullable(z.string()).optional(),
    name: z.string(),
  });

/** @internal */
export type Option2$Outbound = {
  id: string;
  remote_id?: string | null | undefined;
  name: string;
};

/** @internal */
export const Option2$outboundSchema: z.ZodType<
  Option2$Outbound,
  z.ZodTypeDef,
  Option2
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()).optional(),
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Option2$ {
  /** @deprecated use `Option2$inboundSchema` instead. */
  export const inboundSchema = Option2$inboundSchema;
  /** @deprecated use `Option2$outboundSchema` instead. */
  export const outboundSchema = Option2$outboundSchema;
  /** @deprecated use `Option2$Outbound` instead. */
  export type Outbound = Option2$Outbound;
}

export function option2ToJSON(option2: Option2): string {
  return JSON.stringify(Option2$outboundSchema.parse(option2));
}

export function option2FromJSON(
  jsonString: string,
): SafeParseResult<Option2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Option2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Option2' from JSON`,
  );
}

/** @internal */
export const FormatMultiSelect$inboundSchema: z.ZodType<
  FormatMultiSelect,
  z.ZodTypeDef,
  unknown
> = z.object({
  options: z.array(z.lazy(() => Option2$inboundSchema)),
  type: z.literal("MULTI_SELECT"),
});

/** @internal */
export type FormatMultiSelect$Outbound = {
  options: Array<Option2$Outbound>;
  type: "MULTI_SELECT";
};

/** @internal */
export const FormatMultiSelect$outboundSchema: z.ZodType<
  FormatMultiSelect$Outbound,
  z.ZodTypeDef,
  FormatMultiSelect
> = z.object({
  options: z.array(z.lazy(() => Option2$outboundSchema)),
  type: z.literal("MULTI_SELECT"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatMultiSelect$ {
  /** @deprecated use `FormatMultiSelect$inboundSchema` instead. */
  export const inboundSchema = FormatMultiSelect$inboundSchema;
  /** @deprecated use `FormatMultiSelect$outboundSchema` instead. */
  export const outboundSchema = FormatMultiSelect$outboundSchema;
  /** @deprecated use `FormatMultiSelect$Outbound` instead. */
  export type Outbound = FormatMultiSelect$Outbound;
}

export function formatMultiSelectToJSON(
  formatMultiSelect: FormatMultiSelect,
): string {
  return JSON.stringify(
    FormatMultiSelect$outboundSchema.parse(formatMultiSelect),
  );
}

export function formatMultiSelectFromJSON(
  jsonString: string,
): SafeParseResult<FormatMultiSelect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatMultiSelect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatMultiSelect' from JSON`,
  );
}

/** @internal */
export const FormatDate$inboundSchema: z.ZodType<
  FormatDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("DATE"),
});

/** @internal */
export type FormatDate$Outbound = {
  type: "DATE";
};

/** @internal */
export const FormatDate$outboundSchema: z.ZodType<
  FormatDate$Outbound,
  z.ZodTypeDef,
  FormatDate
> = z.object({
  type: z.literal("DATE"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatDate$ {
  /** @deprecated use `FormatDate$inboundSchema` instead. */
  export const inboundSchema = FormatDate$inboundSchema;
  /** @deprecated use `FormatDate$outboundSchema` instead. */
  export const outboundSchema = FormatDate$outboundSchema;
  /** @deprecated use `FormatDate$Outbound` instead. */
  export type Outbound = FormatDate$Outbound;
}

export function formatDateToJSON(formatDate: FormatDate): string {
  return JSON.stringify(FormatDate$outboundSchema.parse(formatDate));
}

export function formatDateFromJSON(
  jsonString: string,
): SafeParseResult<FormatDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatDate' from JSON`,
  );
}

/** @internal */
export const FormatBoolean$inboundSchema: z.ZodType<
  FormatBoolean,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("BOOLEAN"),
});

/** @internal */
export type FormatBoolean$Outbound = {
  type: "BOOLEAN";
};

/** @internal */
export const FormatBoolean$outboundSchema: z.ZodType<
  FormatBoolean$Outbound,
  z.ZodTypeDef,
  FormatBoolean
> = z.object({
  type: z.literal("BOOLEAN"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatBoolean$ {
  /** @deprecated use `FormatBoolean$inboundSchema` instead. */
  export const inboundSchema = FormatBoolean$inboundSchema;
  /** @deprecated use `FormatBoolean$outboundSchema` instead. */
  export const outboundSchema = FormatBoolean$outboundSchema;
  /** @deprecated use `FormatBoolean$Outbound` instead. */
  export type Outbound = FormatBoolean$Outbound;
}

export function formatBooleanToJSON(formatBoolean: FormatBoolean): string {
  return JSON.stringify(FormatBoolean$outboundSchema.parse(formatBoolean));
}

export function formatBooleanFromJSON(
  jsonString: string,
): SafeParseResult<FormatBoolean, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatBoolean$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatBoolean' from JSON`,
  );
}

/** @internal */
export const DisplayType3$inboundSchema: z.ZodNativeEnum<typeof DisplayType3> =
  z.nativeEnum(DisplayType3);

/** @internal */
export const DisplayType3$outboundSchema: z.ZodNativeEnum<typeof DisplayType3> =
  DisplayType3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DisplayType3$ {
  /** @deprecated use `DisplayType3$inboundSchema` instead. */
  export const inboundSchema = DisplayType3$inboundSchema;
  /** @deprecated use `DisplayType3$outboundSchema` instead. */
  export const outboundSchema = DisplayType3$outboundSchema;
}

/** @internal */
export const Option1$inboundSchema: z.ZodType<Option1, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    remote_id: z.nullable(z.string()).optional(),
    name: z.string(),
  });

/** @internal */
export type Option1$Outbound = {
  id: string;
  remote_id?: string | null | undefined;
  name: string;
};

/** @internal */
export const Option1$outboundSchema: z.ZodType<
  Option1$Outbound,
  z.ZodTypeDef,
  Option1
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()).optional(),
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Option1$ {
  /** @deprecated use `Option1$inboundSchema` instead. */
  export const inboundSchema = Option1$inboundSchema;
  /** @deprecated use `Option1$outboundSchema` instead. */
  export const outboundSchema = Option1$outboundSchema;
  /** @deprecated use `Option1$Outbound` instead. */
  export type Outbound = Option1$Outbound;
}

export function option1ToJSON(option1: Option1): string {
  return JSON.stringify(Option1$outboundSchema.parse(option1));
}

export function option1FromJSON(
  jsonString: string,
): SafeParseResult<Option1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Option1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Option1' from JSON`,
  );
}

/** @internal */
export const FormatSingleSelect$inboundSchema: z.ZodType<
  FormatSingleSelect,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_type: z.nullable(DisplayType3$inboundSchema).optional(),
  options: z.array(z.lazy(() => Option1$inboundSchema)),
  type: z.literal("SINGLE_SELECT"),
});

/** @internal */
export type FormatSingleSelect$Outbound = {
  display_type?: string | null | undefined;
  options: Array<Option1$Outbound>;
  type: "SINGLE_SELECT";
};

/** @internal */
export const FormatSingleSelect$outboundSchema: z.ZodType<
  FormatSingleSelect$Outbound,
  z.ZodTypeDef,
  FormatSingleSelect
> = z.object({
  display_type: z.nullable(DisplayType3$outboundSchema).optional(),
  options: z.array(z.lazy(() => Option1$outboundSchema)),
  type: z.literal("SINGLE_SELECT"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatSingleSelect$ {
  /** @deprecated use `FormatSingleSelect$inboundSchema` instead. */
  export const inboundSchema = FormatSingleSelect$inboundSchema;
  /** @deprecated use `FormatSingleSelect$outboundSchema` instead. */
  export const outboundSchema = FormatSingleSelect$outboundSchema;
  /** @deprecated use `FormatSingleSelect$Outbound` instead. */
  export type Outbound = FormatSingleSelect$Outbound;
}

export function formatSingleSelectToJSON(
  formatSingleSelect: FormatSingleSelect,
): string {
  return JSON.stringify(
    FormatSingleSelect$outboundSchema.parse(formatSingleSelect),
  );
}

export function formatSingleSelectFromJSON(
  jsonString: string,
): SafeParseResult<FormatSingleSelect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatSingleSelect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatSingleSelect' from JSON`,
  );
}

/** @internal */
export const FormatFile$inboundSchema: z.ZodType<
  FormatFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  accepted_mime_types: z.nullable(z.array(z.string())).optional(),
  max_file_size_bytes: z.nullable(z.number().int()).optional(),
  type: z.literal("FILE"),
});

/** @internal */
export type FormatFile$Outbound = {
  accepted_mime_types?: Array<string> | null | undefined;
  max_file_size_bytes?: number | null | undefined;
  type: "FILE";
};

/** @internal */
export const FormatFile$outboundSchema: z.ZodType<
  FormatFile$Outbound,
  z.ZodTypeDef,
  FormatFile
> = z.object({
  accepted_mime_types: z.nullable(z.array(z.string())).optional(),
  max_file_size_bytes: z.nullable(z.number().int()).optional(),
  type: z.literal("FILE"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatFile$ {
  /** @deprecated use `FormatFile$inboundSchema` instead. */
  export const inboundSchema = FormatFile$inboundSchema;
  /** @deprecated use `FormatFile$outboundSchema` instead. */
  export const outboundSchema = FormatFile$outboundSchema;
  /** @deprecated use `FormatFile$Outbound` instead. */
  export type Outbound = FormatFile$Outbound;
}

export function formatFileToJSON(formatFile: FormatFile): string {
  return JSON.stringify(FormatFile$outboundSchema.parse(formatFile));
}

export function formatFileFromJSON(
  jsonString: string,
): SafeParseResult<FormatFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatFile' from JSON`,
  );
}

/** @internal */
export const DisplayType2$inboundSchema: z.ZodNativeEnum<typeof DisplayType2> =
  z.nativeEnum(DisplayType2);

/** @internal */
export const DisplayType2$outboundSchema: z.ZodNativeEnum<typeof DisplayType2> =
  DisplayType2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DisplayType2$ {
  /** @deprecated use `DisplayType2$inboundSchema` instead. */
  export const inboundSchema = DisplayType2$inboundSchema;
  /** @deprecated use `DisplayType2$outboundSchema` instead. */
  export const outboundSchema = DisplayType2$outboundSchema;
}

/** @internal */
export const FormatNumber$inboundSchema: z.ZodType<
  FormatNumber,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_type: z.nullable(DisplayType2$inboundSchema.default("FIELD")),
  max: z.nullable(z.number()).optional(),
  min: z.nullable(z.number()).optional(),
  type: z.literal("NUMBER"),
});

/** @internal */
export type FormatNumber$Outbound = {
  display_type: string | null;
  max?: number | null | undefined;
  min?: number | null | undefined;
  type: "NUMBER";
};

/** @internal */
export const FormatNumber$outboundSchema: z.ZodType<
  FormatNumber$Outbound,
  z.ZodTypeDef,
  FormatNumber
> = z.object({
  display_type: z.nullable(DisplayType2$outboundSchema.default("FIELD")),
  max: z.nullable(z.number()).optional(),
  min: z.nullable(z.number()).optional(),
  type: z.literal("NUMBER"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatNumber$ {
  /** @deprecated use `FormatNumber$inboundSchema` instead. */
  export const inboundSchema = FormatNumber$inboundSchema;
  /** @deprecated use `FormatNumber$outboundSchema` instead. */
  export const outboundSchema = FormatNumber$outboundSchema;
  /** @deprecated use `FormatNumber$Outbound` instead. */
  export type Outbound = FormatNumber$Outbound;
}

export function formatNumberToJSON(formatNumber: FormatNumber): string {
  return JSON.stringify(FormatNumber$outboundSchema.parse(formatNumber));
}

export function formatNumberFromJSON(
  jsonString: string,
): SafeParseResult<FormatNumber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatNumber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatNumber' from JSON`,
  );
}

/** @internal */
export const DisplayType1$inboundSchema: z.ZodNativeEnum<typeof DisplayType1> =
  z.nativeEnum(DisplayType1);

/** @internal */
export const DisplayType1$outboundSchema: z.ZodNativeEnum<typeof DisplayType1> =
  DisplayType1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DisplayType1$ {
  /** @deprecated use `DisplayType1$inboundSchema` instead. */
  export const inboundSchema = DisplayType1$inboundSchema;
  /** @deprecated use `DisplayType1$outboundSchema` instead. */
  export const outboundSchema = DisplayType1$outboundSchema;
}

/** @internal */
export const FormatText$inboundSchema: z.ZodType<
  FormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_type: z.nullable(DisplayType1$inboundSchema).optional(),
  max_length: z.nullable(z.number().int()).optional(),
  type: z.literal("TEXT"),
});

/** @internal */
export type FormatText$Outbound = {
  display_type?: string | null | undefined;
  max_length?: number | null | undefined;
  type: "TEXT";
};

/** @internal */
export const FormatText$outboundSchema: z.ZodType<
  FormatText$Outbound,
  z.ZodTypeDef,
  FormatText
> = z.object({
  display_type: z.nullable(DisplayType1$outboundSchema).optional(),
  max_length: z.nullable(z.number().int()).optional(),
  type: z.literal("TEXT"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FormatText$ {
  /** @deprecated use `FormatText$inboundSchema` instead. */
  export const inboundSchema = FormatText$inboundSchema;
  /** @deprecated use `FormatText$outboundSchema` instead. */
  export const outboundSchema = FormatText$outboundSchema;
  /** @deprecated use `FormatText$Outbound` instead. */
  export type Outbound = FormatText$Outbound;
}

export function formatTextToJSON(formatText: FormatText): string {
  return JSON.stringify(FormatText$outboundSchema.parse(formatText));
}

export function formatTextFromJSON(
  jsonString: string,
): SafeParseResult<FormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatText' from JSON`,
  );
}

/** @internal */
export const Format$inboundSchema: z.ZodType<Format, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => FormatSingleSelect$inboundSchema),
    z.lazy(() => FormatMultiSelect$inboundSchema),
    z.lazy(() => FormatText$inboundSchema),
    z.lazy(() => FormatNumber$inboundSchema),
    z.lazy(() => FormatFile$inboundSchema),
    z.lazy(() => FormatBoolean$inboundSchema),
    z.lazy(() => FormatDate$inboundSchema),
    z.lazy(() => FormatInformation$inboundSchema),
    z.lazy(() => FormatUnknown$inboundSchema),
  ]);

/** @internal */
export type Format$Outbound =
  | FormatSingleSelect$Outbound
  | FormatMultiSelect$Outbound
  | FormatText$Outbound
  | FormatNumber$Outbound
  | FormatFile$Outbound
  | FormatBoolean$Outbound
  | FormatDate$Outbound
  | FormatInformation$Outbound
  | FormatUnknown$Outbound;

/** @internal */
export const Format$outboundSchema: z.ZodType<
  Format$Outbound,
  z.ZodTypeDef,
  Format
> = z.union([
  z.lazy(() => FormatSingleSelect$outboundSchema),
  z.lazy(() => FormatMultiSelect$outboundSchema),
  z.lazy(() => FormatText$outboundSchema),
  z.lazy(() => FormatNumber$outboundSchema),
  z.lazy(() => FormatFile$outboundSchema),
  z.lazy(() => FormatBoolean$outboundSchema),
  z.lazy(() => FormatDate$outboundSchema),
  z.lazy(() => FormatInformation$outboundSchema),
  z.lazy(() => FormatUnknown$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Format$ {
  /** @deprecated use `Format$inboundSchema` instead. */
  export const inboundSchema = Format$inboundSchema;
  /** @deprecated use `Format$outboundSchema` instead. */
  export const outboundSchema = Format$outboundSchema;
  /** @deprecated use `Format$Outbound` instead. */
  export type Outbound = Format$Outbound;
}

export function formatToJSON(format: Format): string {
  return JSON.stringify(Format$outboundSchema.parse(format));
}

export function formatFromJSON(
  jsonString: string,
): SafeParseResult<Format, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Format$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Format' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseCategory$inboundSchema: z.ZodNativeEnum<
  typeof GetAtsJobsPositiveResponseCategory
> = z.nativeEnum(GetAtsJobsPositiveResponseCategory);

/** @internal */
export const GetAtsJobsPositiveResponseCategory$outboundSchema: z.ZodNativeEnum<
  typeof GetAtsJobsPositiveResponseCategory
> = GetAtsJobsPositiveResponseCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseCategory$ {
  /** @deprecated use `GetAtsJobsPositiveResponseCategory$inboundSchema` instead. */
  export const inboundSchema = GetAtsJobsPositiveResponseCategory$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseCategory$outboundSchema` instead. */
  export const outboundSchema =
    GetAtsJobsPositiveResponseCategory$outboundSchema;
}

/** @internal */
export const PreconditionOptions$inboundSchema: z.ZodType<
  PreconditionOptions,
  z.ZodTypeDef,
  unknown
> = z.union([z.array(z.string()), z.array(z.boolean())]);

/** @internal */
export type PreconditionOptions$Outbound = Array<string> | Array<boolean>;

/** @internal */
export const PreconditionOptions$outboundSchema: z.ZodType<
  PreconditionOptions$Outbound,
  z.ZodTypeDef,
  PreconditionOptions
> = z.union([z.array(z.string()), z.array(z.boolean())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreconditionOptions$ {
  /** @deprecated use `PreconditionOptions$inboundSchema` instead. */
  export const inboundSchema = PreconditionOptions$inboundSchema;
  /** @deprecated use `PreconditionOptions$outboundSchema` instead. */
  export const outboundSchema = PreconditionOptions$outboundSchema;
  /** @deprecated use `PreconditionOptions$Outbound` instead. */
  export type Outbound = PreconditionOptions$Outbound;
}

export function preconditionOptionsToJSON(
  preconditionOptions: PreconditionOptions,
): string {
  return JSON.stringify(
    PreconditionOptions$outboundSchema.parse(preconditionOptions),
  );
}

export function preconditionOptionsFromJSON(
  jsonString: string,
): SafeParseResult<PreconditionOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreconditionOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreconditionOptions' from JSON`,
  );
}

/** @internal */
export const ScreeningQuestion$inboundSchema: z.ZodType<
  ScreeningQuestion,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  format: z.nullable(
    z.union([
      z.lazy(() => FormatSingleSelect$inboundSchema),
      z.lazy(() => FormatMultiSelect$inboundSchema),
      z.lazy(() => FormatText$inboundSchema),
      z.lazy(() => FormatNumber$inboundSchema),
      z.lazy(() => FormatFile$inboundSchema),
      z.lazy(() => FormatBoolean$inboundSchema),
      z.lazy(() => FormatDate$inboundSchema),
      z.lazy(() => FormatInformation$inboundSchema),
      z.lazy(() => FormatUnknown$inboundSchema),
    ]),
  ).optional(),
  category: z.nullable(GetAtsJobsPositiveResponseCategory$inboundSchema),
  index: z.nullable(z.number().int()).optional(),
  required: z.nullable(z.boolean()),
  precondition_question_id: z.nullable(z.string()).optional(),
  precondition_options: z.nullable(
    z.union([z.array(z.string()), z.array(z.boolean())]),
  ).optional(),
});

/** @internal */
export type ScreeningQuestion$Outbound = {
  id: string;
  remote_id: string | null;
  title: string | null;
  description: string | null;
  format?:
    | FormatSingleSelect$Outbound
    | FormatMultiSelect$Outbound
    | FormatText$Outbound
    | FormatNumber$Outbound
    | FormatFile$Outbound
    | FormatBoolean$Outbound
    | FormatDate$Outbound
    | FormatInformation$Outbound
    | FormatUnknown$Outbound
    | null
    | undefined;
  category: string | null;
  index?: number | null | undefined;
  required: boolean | null;
  precondition_question_id?: string | null | undefined;
  precondition_options?: Array<string> | Array<boolean> | null | undefined;
};

/** @internal */
export const ScreeningQuestion$outboundSchema: z.ZodType<
  ScreeningQuestion$Outbound,
  z.ZodTypeDef,
  ScreeningQuestion
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  format: z.nullable(
    z.union([
      z.lazy(() => FormatSingleSelect$outboundSchema),
      z.lazy(() => FormatMultiSelect$outboundSchema),
      z.lazy(() => FormatText$outboundSchema),
      z.lazy(() => FormatNumber$outboundSchema),
      z.lazy(() => FormatFile$outboundSchema),
      z.lazy(() => FormatBoolean$outboundSchema),
      z.lazy(() => FormatDate$outboundSchema),
      z.lazy(() => FormatInformation$outboundSchema),
      z.lazy(() => FormatUnknown$outboundSchema),
    ]),
  ).optional(),
  category: z.nullable(GetAtsJobsPositiveResponseCategory$outboundSchema),
  index: z.nullable(z.number().int()).optional(),
  required: z.nullable(z.boolean()),
  precondition_question_id: z.nullable(z.string()).optional(),
  precondition_options: z.nullable(
    z.union([z.array(z.string()), z.array(z.boolean())]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScreeningQuestion$ {
  /** @deprecated use `ScreeningQuestion$inboundSchema` instead. */
  export const inboundSchema = ScreeningQuestion$inboundSchema;
  /** @deprecated use `ScreeningQuestion$outboundSchema` instead. */
  export const outboundSchema = ScreeningQuestion$outboundSchema;
  /** @deprecated use `ScreeningQuestion$Outbound` instead. */
  export type Outbound = ScreeningQuestion$Outbound;
}

export function screeningQuestionToJSON(
  screeningQuestion: ScreeningQuestion,
): string {
  return JSON.stringify(
    ScreeningQuestion$outboundSchema.parse(screeningQuestion),
  );
}

export function screeningQuestionFromJSON(
  jsonString: string,
): SafeParseResult<ScreeningQuestion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScreeningQuestion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScreeningQuestion' from JSON`,
  );
}

/** @internal */
export const JobPostingStatus$inboundSchema: z.ZodNativeEnum<
  typeof JobPostingStatus
> = z.nativeEnum(JobPostingStatus);

/** @internal */
export const JobPostingStatus$outboundSchema: z.ZodNativeEnum<
  typeof JobPostingStatus
> = JobPostingStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace JobPostingStatus$ {
  /** @deprecated use `JobPostingStatus$inboundSchema` instead. */
  export const inboundSchema = JobPostingStatus$inboundSchema;
  /** @deprecated use `JobPostingStatus$outboundSchema` instead. */
  export const outboundSchema = JobPostingStatus$outboundSchema;
}

/** @internal */
export const JobPostingVisibility$inboundSchema: z.ZodNativeEnum<
  typeof JobPostingVisibility
> = z.nativeEnum(JobPostingVisibility);

/** @internal */
export const JobPostingVisibility$outboundSchema: z.ZodNativeEnum<
  typeof JobPostingVisibility
> = JobPostingVisibility$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace JobPostingVisibility$ {
  /** @deprecated use `JobPostingVisibility$inboundSchema` instead. */
  export const inboundSchema = JobPostingVisibility$inboundSchema;
  /** @deprecated use `JobPostingVisibility$outboundSchema` instead. */
  export const outboundSchema = JobPostingVisibility$outboundSchema;
}

/** @internal */
export const JobPosting$inboundSchema: z.ZodType<
  JobPosting,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description_html: z.nullable(z.string()),
  status: z.nullable(JobPostingStatus$inboundSchema),
  visibility: z.nullable(JobPostingVisibility$inboundSchema),
  url: z.nullable(z.string()),
});

/** @internal */
export type JobPosting$Outbound = {
  id: string;
  remote_id: string | null;
  title: string | null;
  description_html: string | null;
  status: string | null;
  visibility: string | null;
  url: string | null;
};

/** @internal */
export const JobPosting$outboundSchema: z.ZodType<
  JobPosting$Outbound,
  z.ZodTypeDef,
  JobPosting
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description_html: z.nullable(z.string()),
  status: z.nullable(JobPostingStatus$outboundSchema),
  visibility: z.nullable(JobPostingVisibility$outboundSchema),
  url: z.nullable(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace JobPosting$ {
  /** @deprecated use `JobPosting$inboundSchema` instead. */
  export const inboundSchema = JobPosting$inboundSchema;
  /** @deprecated use `JobPosting$outboundSchema` instead. */
  export const outboundSchema = JobPosting$outboundSchema;
  /** @deprecated use `JobPosting$Outbound` instead. */
  export type Outbound = JobPosting$Outbound;
}

export function jobPostingToJSON(jobPosting: JobPosting): string {
  return JSON.stringify(JobPosting$outboundSchema.parse(jobPosting));
}

export function jobPostingFromJSON(
  jsonString: string,
): SafeParseResult<JobPosting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobPosting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobPosting' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema:
  z.ZodNativeEnum<typeof GetAtsJobsPositiveResponseHiringTeamRole> = z
    .nativeEnum(GetAtsJobsPositiveResponseHiringTeamRole);

/** @internal */
export const GetAtsJobsPositiveResponseHiringTeamRole$outboundSchema:
  z.ZodNativeEnum<typeof GetAtsJobsPositiveResponseHiringTeamRole> =
    GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseHiringTeamRole$ {
  /** @deprecated use `GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema` instead. */
  export const inboundSchema =
    GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseHiringTeamRole$outboundSchema` instead. */
  export const outboundSchema =
    GetAtsJobsPositiveResponseHiringTeamRole$outboundSchema;
}

/** @internal */
export const GetAtsJobsPositiveResponseHiringTeam$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseHiringTeam,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  email: z.nullable(z.string()).optional(),
  hiring_team_roles: z.array(
    GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema,
  ),
});

/** @internal */
export type GetAtsJobsPositiveResponseHiringTeam$Outbound = {
  id: string;
  remote_id: string | null;
  first_name: string | null;
  last_name: string | null;
  email?: string | null | undefined;
  hiring_team_roles: Array<string>;
};

/** @internal */
export const GetAtsJobsPositiveResponseHiringTeam$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseHiringTeam$Outbound,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponseHiringTeam
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  email: z.nullable(z.string()).optional(),
  hiring_team_roles: z.array(
    GetAtsJobsPositiveResponseHiringTeamRole$outboundSchema,
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseHiringTeam$ {
  /** @deprecated use `GetAtsJobsPositiveResponseHiringTeam$inboundSchema` instead. */
  export const inboundSchema =
    GetAtsJobsPositiveResponseHiringTeam$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseHiringTeam$outboundSchema` instead. */
  export const outboundSchema =
    GetAtsJobsPositiveResponseHiringTeam$outboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseHiringTeam$Outbound` instead. */
  export type Outbound = GetAtsJobsPositiveResponseHiringTeam$Outbound;
}

export function getAtsJobsPositiveResponseHiringTeamToJSON(
  getAtsJobsPositiveResponseHiringTeam: GetAtsJobsPositiveResponseHiringTeam,
): string {
  return JSON.stringify(
    GetAtsJobsPositiveResponseHiringTeam$outboundSchema.parse(
      getAtsJobsPositiveResponseHiringTeam,
    ),
  );
}

export function getAtsJobsPositiveResponseHiringTeamFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseHiringTeam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsJobsPositiveResponseHiringTeam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseHiringTeam' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseResult$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  name: z.nullable(z.string()),
  job_code: z.nullable(z.string()),
  description: z.nullable(z.string()),
  confidential: z.nullable(z.boolean()),
  weekly_hours: z.nullable(z.number()),
  employment_type: z.nullable(
    GetAtsJobsPositiveResponseEmploymentType$inboundSchema,
  ).optional(),
  status: z.nullable(GetAtsJobsPositiveResponseStatus$inboundSchema).optional(),
  visibility: z.nullable(Visibility$inboundSchema).optional(),
  category: z.nullable(z.string()),
  department: z.nullable(z.string()),
  post_url: z.nullable(z.string()),
  experience_level: z.nullable(z.string()),
  remote_work_status: z.nullable(RemoteWorkStatus$inboundSchema).optional(),
  salary_amount: z.nullable(z.number()),
  salary_amount_from: z.nullable(z.number()),
  salary_amount_to: z.nullable(z.number()),
  salary_currency: z.nullable(z.string()),
  salary_period: z.nullable(SalaryPeriod$inboundSchema).optional(),
  location: z.nullable(
    z.lazy(() => GetAtsJobsPositiveResponseLocation$inboundSchema),
  ).optional(),
  custom_fields: z.nullable(z.record(z.any())),
  remote_url: z.nullable(z.string()),
  opened_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  closed_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  contact_id: z.nullable(z.string()),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  stages: z.array(z.lazy(() => Stage$inboundSchema)),
  screening_questions: z.array(z.lazy(() => ScreeningQuestion$inboundSchema)),
  job_postings: z.array(z.lazy(() => JobPosting$inboundSchema)),
  hiring_team: z.array(
    z.lazy(() => GetAtsJobsPositiveResponseHiringTeam$inboundSchema),
  ),
});

/** @internal */
export type GetAtsJobsPositiveResponseResult$Outbound = {
  id: string;
  remote_id: string;
  name: string | null;
  job_code: string | null;
  description: string | null;
  confidential: boolean | null;
  weekly_hours: number | null;
  employment_type?: string | null | undefined;
  status?: string | null | undefined;
  visibility?: string | null | undefined;
  category: string | null;
  department: string | null;
  post_url: string | null;
  experience_level: string | null;
  remote_work_status?: string | null | undefined;
  salary_amount: number | null;
  salary_amount_from: number | null;
  salary_amount_to: number | null;
  salary_currency: string | null;
  salary_period?: string | null | undefined;
  location?: GetAtsJobsPositiveResponseLocation$Outbound | null | undefined;
  custom_fields: { [k: string]: any } | null;
  remote_url: string | null;
  opened_at: string | null;
  closed_at: string | null;
  remote_created_at: string | null;
  remote_updated_at: string | null;
  contact_id: string | null;
  changed_at: string;
  remote_deleted_at: string | null;
  stages: Array<Stage$Outbound>;
  screening_questions: Array<ScreeningQuestion$Outbound>;
  job_postings: Array<JobPosting$Outbound>;
  hiring_team: Array<GetAtsJobsPositiveResponseHiringTeam$Outbound>;
};

/** @internal */
export const GetAtsJobsPositiveResponseResult$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseResult$Outbound,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponseResult
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  name: z.nullable(z.string()),
  job_code: z.nullable(z.string()),
  description: z.nullable(z.string()),
  confidential: z.nullable(z.boolean()),
  weekly_hours: z.nullable(z.number()),
  employment_type: z.nullable(
    GetAtsJobsPositiveResponseEmploymentType$outboundSchema,
  ).optional(),
  status: z.nullable(GetAtsJobsPositiveResponseStatus$outboundSchema)
    .optional(),
  visibility: z.nullable(Visibility$outboundSchema).optional(),
  category: z.nullable(z.string()),
  department: z.nullable(z.string()),
  post_url: z.nullable(z.string()),
  experience_level: z.nullable(z.string()),
  remote_work_status: z.nullable(RemoteWorkStatus$outboundSchema).optional(),
  salary_amount: z.nullable(z.number()),
  salary_amount_from: z.nullable(z.number()),
  salary_amount_to: z.nullable(z.number()),
  salary_currency: z.nullable(z.string()),
  salary_period: z.nullable(SalaryPeriod$outboundSchema).optional(),
  location: z.nullable(
    z.lazy(() => GetAtsJobsPositiveResponseLocation$outboundSchema),
  ).optional(),
  custom_fields: z.nullable(z.record(z.any())),
  remote_url: z.nullable(z.string()),
  opened_at: z.nullable(z.date().transform(v => v.toISOString())),
  closed_at: z.nullable(z.date().transform(v => v.toISOString())),
  remote_created_at: z.nullable(z.date().transform(v => v.toISOString())),
  remote_updated_at: z.nullable(z.date().transform(v => v.toISOString())),
  contact_id: z.nullable(z.string()),
  changed_at: z.date().transform(v => v.toISOString()),
  remote_deleted_at: z.nullable(z.date().transform(v => v.toISOString())),
  stages: z.array(z.lazy(() => Stage$outboundSchema)),
  screening_questions: z.array(z.lazy(() => ScreeningQuestion$outboundSchema)),
  job_postings: z.array(z.lazy(() => JobPosting$outboundSchema)),
  hiring_team: z.array(
    z.lazy(() => GetAtsJobsPositiveResponseHiringTeam$outboundSchema),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseResult$ {
  /** @deprecated use `GetAtsJobsPositiveResponseResult$inboundSchema` instead. */
  export const inboundSchema = GetAtsJobsPositiveResponseResult$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseResult$outboundSchema` instead. */
  export const outboundSchema = GetAtsJobsPositiveResponseResult$outboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseResult$Outbound` instead. */
  export type Outbound = GetAtsJobsPositiveResponseResult$Outbound;
}

export function getAtsJobsPositiveResponseResultToJSON(
  getAtsJobsPositiveResponseResult: GetAtsJobsPositiveResponseResult,
): string {
  return JSON.stringify(
    GetAtsJobsPositiveResponseResult$outboundSchema.parse(
      getAtsJobsPositiveResponseResult,
    ),
  );
}

export function getAtsJobsPositiveResponseResultFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsJobsPositiveResponseResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseResult' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseData$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetAtsJobsPositiveResponseResult$inboundSchema),
  ),
});

/** @internal */
export type GetAtsJobsPositiveResponseData$Outbound = {
  next: string | null;
  results: Array<GetAtsJobsPositiveResponseResult$Outbound>;
};

/** @internal */
export const GetAtsJobsPositiveResponseData$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseData$Outbound,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponseData
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetAtsJobsPositiveResponseResult$outboundSchema),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponseData$ {
  /** @deprecated use `GetAtsJobsPositiveResponseData$inboundSchema` instead. */
  export const inboundSchema = GetAtsJobsPositiveResponseData$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseData$outboundSchema` instead. */
  export const outboundSchema = GetAtsJobsPositiveResponseData$outboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponseData$Outbound` instead. */
  export type Outbound = GetAtsJobsPositiveResponseData$Outbound;
}

export function getAtsJobsPositiveResponseDataToJSON(
  getAtsJobsPositiveResponseData: GetAtsJobsPositiveResponseData,
): string {
  return JSON.stringify(
    GetAtsJobsPositiveResponseData$outboundSchema.parse(
      getAtsJobsPositiveResponseData,
    ),
  );
}

export function getAtsJobsPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsJobsPositiveResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponse$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetAtsJobsPositiveResponseData$inboundSchema),
});

/** @internal */
export type GetAtsJobsPositiveResponse$Outbound = {
  status: "success";
  data: GetAtsJobsPositiveResponseData$Outbound;
};

/** @internal */
export const GetAtsJobsPositiveResponse$outboundSchema: z.ZodType<
  GetAtsJobsPositiveResponse$Outbound,
  z.ZodTypeDef,
  GetAtsJobsPositiveResponse
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetAtsJobsPositiveResponseData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAtsJobsPositiveResponse$ {
  /** @deprecated use `GetAtsJobsPositiveResponse$inboundSchema` instead. */
  export const inboundSchema = GetAtsJobsPositiveResponse$inboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponse$outboundSchema` instead. */
  export const outboundSchema = GetAtsJobsPositiveResponse$outboundSchema;
  /** @deprecated use `GetAtsJobsPositiveResponse$Outbound` instead. */
  export type Outbound = GetAtsJobsPositiveResponse$Outbound;
}

export function getAtsJobsPositiveResponseToJSON(
  getAtsJobsPositiveResponse: GetAtsJobsPositiveResponse,
): string {
  return JSON.stringify(
    GetAtsJobsPositiveResponse$outboundSchema.parse(getAtsJobsPositiveResponse),
  );
}

export function getAtsJobsPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsJobsPositiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponse' from JSON`,
  );
}
