/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { catchUnrecognizedEnum, ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const GetAtsJobsPositiveResponseEmploymentType = {
  FullTime: "FULL_TIME",
  PartTime: "PART_TIME",
  Contract: "CONTRACT",
  Seasonal: "SEASONAL",
  Internship: "INTERNSHIP",
} as const;
export type GetAtsJobsPositiveResponseEmploymentType = OpenEnum<
  typeof GetAtsJobsPositiveResponseEmploymentType
>;

export const GetAtsJobsPositiveResponseStatus = {
  Open: "OPEN",
  Closed: "CLOSED",
  Draft: "DRAFT",
  Archived: "ARCHIVED",
} as const;
export type GetAtsJobsPositiveResponseStatus = OpenEnum<
  typeof GetAtsJobsPositiveResponseStatus
>;

export const Visibility = {
  Public: "PUBLIC",
  Internal: "INTERNAL",
  Unlisted: "UNLISTED",
  Confidential: "CONFIDENTIAL",
} as const;
export type Visibility = OpenEnum<typeof Visibility>;

export const RemoteWorkStatus = {
  Remote: "REMOTE",
  Hybrid: "HYBRID",
  Temporary: "TEMPORARY",
  OnSite: "ON_SITE",
} as const;
export type RemoteWorkStatus = OpenEnum<typeof RemoteWorkStatus>;

export const SalaryPeriod = {
  Year: "YEAR",
  Month: "MONTH",
  TwoWeeks: "TWO_WEEKS",
  Week: "WEEK",
  Day: "DAY",
  Hour: "HOUR",
} as const;
export type SalaryPeriod = OpenEnum<typeof SalaryPeriod>;

/**
 * The location of the listed job.
 */
export type GetAtsJobsPositiveResponseLocation = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type Stage = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The application stage name. For example, "Initial Screening".
   */
  name: string | null;
  /**
   * Numeric index following the order of the stages if they are ordered in the underlying tool.
   */
  index?: number | null | undefined;
};

export type FormatUnknown = {
  /**
   * We pass the original question data along so you can handle it.
   */
  raw_question?: any | undefined;
  /**
   * When we're not able to map a specific question type yet, we will return this type. Every `UNKNOWN` question will also be parsed and unified by us at some point.
   */
  type: "UNKNOWN";
};

export type FormatInformation = {
  /**
   * This is just a text block.
   */
  type: "INFORMATION";
};

export type Option2 = {
  /**
   * The Kombo ID of this question option. Use this ID to specify the answer to this question.
   */
  id: string;
  /**
   * ID in the connected ATS. This might be null as some systems only use the name to identify the option.
   */
  remote_id?: string | null | undefined;
  /**
   * Content of the question option.
   */
  name: string;
};

export type FormatMultiSelect = {
  options: Array<Option2>;
  type: "MULTI_SELECT";
};

export type FormatDate = {
  type: "DATE";
};

export type FormatBoolean = {
  type: "BOOLEAN";
};

export const DisplayType3 = {
  Dropdown: "DROPDOWN",
  Radio: "RADIO",
} as const;
export type DisplayType3 = ClosedEnum<typeof DisplayType3>;

export type Option1 = {
  /**
   * The Kombo ID of this question option. Use this ID to specify the answer to this question.
   */
  id: string;
  /**
   * ID in the connected ATS. This might be null as some systems only use the name to identify the option.
   */
  remote_id?: string | null | undefined;
  /**
   * Content of the question option.
   */
  name: string;
};

export type FormatSingleSelect = {
  display_type?: DisplayType3 | null | undefined;
  options: Array<Option1>;
  type: "SINGLE_SELECT";
};

export type FormatFile = {
  accepted_mime_types?: Array<string> | null | undefined;
  max_file_size_bytes?: number | null | undefined;
  type: "FILE";
};

export const DisplayType2 = {
  Slider: "SLIDER",
  Field: "FIELD",
} as const;
export type DisplayType2 = ClosedEnum<typeof DisplayType2>;

export type FormatNumber = {
  display_type?: DisplayType2 | null | undefined;
  max?: number | null | undefined;
  min?: number | null | undefined;
  type: "NUMBER";
};

/**
 * If unavailable, we recommend displaying a single-line input.
 */
export const DisplayType1 = {
  SingleLine: "SINGLE_LINE",
  MultiLine: "MULTI_LINE",
  Email: "EMAIL",
  Url: "URL",
} as const;
/**
 * If unavailable, we recommend displaying a single-line input.
 */
export type DisplayType1 = ClosedEnum<typeof DisplayType1>;

export type FormatText = {
  /**
   * If unavailable, we recommend displaying a single-line input.
   */
  display_type?: DisplayType1 | null | undefined;
  max_length?: number | null | undefined;
  type: "TEXT";
};

export type Format =
  | FormatSingleSelect
  | FormatMultiSelect
  | FormatText
  | FormatNumber
  | FormatFile
  | FormatBoolean
  | FormatDate
  | FormatInformation
  | FormatUnknown;

/**
 * The category of the screening question (default `null`). "EEO" questions are related to Equal Employment Opportunity (e.g. "What is your veteran status?"), while "DEMOGRAPHIC" questions are for other diversity and demographic data collection.
 */
export const GetAtsJobsPositiveResponseCategory = {
  Eeo: "EEO",
  Demographic: "DEMOGRAPHIC",
} as const;
/**
 * The category of the screening question (default `null`). "EEO" questions are related to Equal Employment Opportunity (e.g. "What is your veteran status?"), while "DEMOGRAPHIC" questions are for other diversity and demographic data collection.
 */
export type GetAtsJobsPositiveResponseCategory = ClosedEnum<
  typeof GetAtsJobsPositiveResponseCategory
>;

/**
 * Where the screening question specified by `precondition_question_id` is of type `MULTI_SELECT` or `SINGLE_SELECT`, this is an array of Kombo IDs describing the valid options. If the question is of type `BOOLEAN`, this is an array containing either `true` or `false`.
 */
export type PreconditionOptions = Array<string> | Array<boolean>;

export type ScreeningQuestion = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  title: string | null;
  /**
   * Additional instructions or context. Typically a short sentence, but sometimes a long detailed description (e.g., for EEO questions). May include HTML for extra formatting.
   */
  description: string | null;
  format?:
    | FormatSingleSelect
    | FormatMultiSelect
    | FormatText
    | FormatNumber
    | FormatFile
    | FormatBoolean
    | FormatDate
    | FormatInformation
    | FormatUnknown
    | null
    | undefined;
  /**
   * The category of the screening question (default `null`). "EEO" questions are related to Equal Employment Opportunity (e.g. "What is your veteran status?"), while "DEMOGRAPHIC" questions are for other diversity and demographic data collection.
   */
  category: GetAtsJobsPositiveResponseCategory | null;
  index?: number | null | undefined;
  required: boolean | null;
  /**
   * The Kombo ID of another screening question. Only display this question if the specified "precondition question" is answered with one of the values in `precondition_options`.
   */
  precondition_question_id?: string | null | undefined;
  /**
   * Where the screening question specified by `precondition_question_id` is of type `MULTI_SELECT` or `SINGLE_SELECT`, this is an array of Kombo IDs describing the valid options. If the question is of type `BOOLEAN`, this is an array containing either `true` or `false`.
   */
  precondition_options?: Array<string> | Array<boolean> | null | undefined;
};

/**
 * The job posting’s current status.
 */
export const JobPostingStatus = {
  Active: "ACTIVE",
  Inactive: "INACTIVE",
  Draft: "DRAFT",
} as const;
/**
 * The job posting’s current status.
 */
export type JobPostingStatus = ClosedEnum<typeof JobPostingStatus>;

export const JobPostingVisibility = {
  Public: "PUBLIC",
  Internal: "INTERNAL",
  Unlisted: "UNLISTED",
} as const;
export type JobPostingVisibility = ClosedEnum<typeof JobPostingVisibility>;

export type JobPosting = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The job posting’s title.
   */
  title: string | null;
  /**
   * The job posting’s description in HTML format.
   */
  description_html: string | null;
  /**
   * The job posting’s current status.
   */
  status: JobPostingStatus | null;
  visibility: JobPostingVisibility | null;
  /**
   * The public URL to the job posting on the ATS platform.
   */
  url: string | null;
};

export const GetAtsJobsPositiveResponseHiringTeamRole = {
  Recruiter: "RECRUITER",
  HiringManager: "HIRING_MANAGER",
} as const;
export type GetAtsJobsPositiveResponseHiringTeamRole = ClosedEnum<
  typeof GetAtsJobsPositiveResponseHiringTeamRole
>;

export type GetAtsJobsPositiveResponseHiringTeam = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * First name of the user.
   */
  first_name: string | null;
  /**
   * Last name of the user.
   */
  last_name: string | null;
  /**
   * Email of the user. If the email address is invalid, it will be set to null.
   */
  email?: string | null | undefined;
  /**
   * Array of the roles of the user for this specific job. Currently only `RECRUITER` and `HIRING_MANAGER` are mapped into our unified schema.
   */
  hiring_team_roles: Array<GetAtsJobsPositiveResponseHiringTeamRole>;
};

export type GetAtsJobsPositiveResponseResult = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * Title of the job.
   */
  name: string | null;
  /**
   * The human readable job code. Some systems expose this as the Requisition Code/ID.
   */
  job_code: string | null;
  /**
   * Description of the job. This field is usually returned as HTML.
   */
  description: string | null;
  /**
   * **(⚠️ Deprecated)** It makes more sense to store the visibility of a job in an enum. Therefore, we introduced the `visibility` enum on jobs.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  confidential: boolean | null;
  /**
   * The number of hours per week an employee is expected to work.
   */
  weekly_hours: number | null;
  /**
   * The type of employment contract. In rare cases where can't find a clear mapping, the original string is passed through.
   */
  employment_type?: GetAtsJobsPositiveResponseEmploymentType | null | undefined;
  /**
   * The job's current status.
   *
   * @remarks
   *
   * *Note: For any checks (e.g., "can we publish this job?"), always evaluate both `status` and `visibility`. For example, a job can be `status=OPEN` with `visibility=INTERNAL`, meaning only existing employees can apply.*
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  status?: GetAtsJobsPositiveResponseStatus | null | undefined;
  /**
   * Describes the visibility of the job:
   *
   * @remarks
   *
   * - `PUBLIC`: visible to everyone, published on a job board
   * - `INTERNAL`: only visible to employees of the company itself
   * - `UNLISTED`: anyone can apply but only if they have the link to it
   * - `CONFIDENTIAL`: nobody can apply and it's only visible in the ATS to people who were invited to it
   *
   * *Note: For any checks (e.g., "can we publish this job?"), always evaluate both `status` and `visibility`.*
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  visibility?: Visibility | null | undefined;
  /**
   * The category of the job (often the job industry). The original string is passed through, for example "Information Technology", "Quality Assurance", "Marketing".
   */
  category: string | null;
  /**
   * The internal department or team the job belongs to. The original string is passed through, for example "IT/Operations", "Engineering - Platform", "Customer Success".
   */
  department: string | null;
  /**
   * The public job posting URL of the ATS itself. This can be used by external job boards to redirect applicants.
   */
  post_url: string | null;
  /**
   * The role's seniority or experience level. The original string is passed through, for example "Mid-Senior Level", "5+ years", "Associate", "IC3".
   */
  experience_level: string | null;
  /**
   * Defines if the job supports remote work and if so, to what extent.
   */
  remote_work_status?: RemoteWorkStatus | null | undefined;
  /**
   * The salary amount in the given currency.
   */
  salary_amount: number | null;
  /**
   * The lower bound of the salary range.
   */
  salary_amount_from: number | null;
  /**
   * The upper bound of the salary range.
   */
  salary_amount_to: number | null;
  /**
   * Salary currency usually returned in [ISO 4217 currency codes](https://www.iso.org/iso-4217-currency-codes.html).
   */
  salary_currency: string | null;
  /**
   * The period of time over which the salary amount is paid (not equal to the pay frequency). In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  salary_period?: SalaryPeriod | null | undefined;
  /**
   * The location of the listed job.
   */
  location?: GetAtsJobsPositiveResponseLocation | null | undefined;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
  /**
   * URL to the job posting in the source ATS system.
   */
  remote_url: string | null;
  /**
   * YYYY-MM-DDTHH:mm:ss.sssZ
   */
  opened_at: Date | null;
  /**
   * The date the job closed or is scheduled to close. A future value typically indicates the job remains open for applications until that date.
   *
   * @remarks
   *
   * Please use the `status` and `visibility` fields to determine if a job can be published.
   */
  closed_at: Date | null;
  /**
   * The date and time the object was created in the remote system.
   */
  remote_created_at: Date | null;
  /**
   * A timestamp retrieved from the remote system, describing when the resource was last updated.
   */
  remote_updated_at: Date | null;
  /**
   * **(⚠️ Deprecated)** The user ID of the contact person for this job. We strongly recommend using the new `hiring_team` property instead as it provides more complete and accurate information about the ATS users connected to a job.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact_id: string | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * Application stages a candidate can be in for this particular job.
   */
  stages: Array<Stage>;
  screening_questions: Array<ScreeningQuestion>;
  job_postings: Array<JobPosting>;
  /**
   * The hiring team allows you to sync users into your system who can access the job and its applications.
   */
  hiring_team: Array<GetAtsJobsPositiveResponseHiringTeam>;
};

export type GetAtsJobsPositiveResponseData = {
  /**
   * Cursor string that can be passed to the `cursor` query parameter to get the next page. If this is `null`, then there are no more pages.
   */
  next: string | null;
  results: Array<GetAtsJobsPositiveResponseResult>;
};

export type GetAtsJobsPositiveResponse = {
  status: "success";
  data: GetAtsJobsPositiveResponseData;
};

/** @internal */
export const GetAtsJobsPositiveResponseEmploymentType$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseEmploymentType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetAtsJobsPositiveResponseEmploymentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetAtsJobsPositiveResponseStatus$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetAtsJobsPositiveResponseStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Visibility$inboundSchema: z.ZodType<
  Visibility,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Visibility),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RemoteWorkStatus$inboundSchema: z.ZodType<
  RemoteWorkStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RemoteWorkStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const SalaryPeriod$inboundSchema: z.ZodType<
  SalaryPeriod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SalaryPeriod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetAtsJobsPositiveResponseLocation$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

export function getAtsJobsPositiveResponseLocationFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseLocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsJobsPositiveResponseLocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseLocation' from JSON`,
  );
}

/** @internal */
export const Stage$inboundSchema: z.ZodType<Stage, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    remote_id: z.nullable(z.string()),
    name: z.nullable(z.string()),
    index: z.nullable(z.number().int()).optional(),
  });

export function stageFromJSON(
  jsonString: string,
): SafeParseResult<Stage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stage' from JSON`,
  );
}

/** @internal */
export const FormatUnknown$inboundSchema: z.ZodType<
  FormatUnknown,
  z.ZodTypeDef,
  unknown
> = z.object({
  raw_question: z.any().optional(),
  type: z.literal("UNKNOWN"),
});

export function formatUnknownFromJSON(
  jsonString: string,
): SafeParseResult<FormatUnknown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatUnknown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatUnknown' from JSON`,
  );
}

/** @internal */
export const FormatInformation$inboundSchema: z.ZodType<
  FormatInformation,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("INFORMATION"),
});

export function formatInformationFromJSON(
  jsonString: string,
): SafeParseResult<FormatInformation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatInformation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatInformation' from JSON`,
  );
}

/** @internal */
export const Option2$inboundSchema: z.ZodType<Option2, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    remote_id: z.nullable(z.string()).optional(),
    name: z.string(),
  });

export function option2FromJSON(
  jsonString: string,
): SafeParseResult<Option2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Option2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Option2' from JSON`,
  );
}

/** @internal */
export const FormatMultiSelect$inboundSchema: z.ZodType<
  FormatMultiSelect,
  z.ZodTypeDef,
  unknown
> = z.object({
  options: z.array(z.lazy(() => Option2$inboundSchema)),
  type: z.literal("MULTI_SELECT"),
});

export function formatMultiSelectFromJSON(
  jsonString: string,
): SafeParseResult<FormatMultiSelect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatMultiSelect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatMultiSelect' from JSON`,
  );
}

/** @internal */
export const FormatDate$inboundSchema: z.ZodType<
  FormatDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("DATE"),
});

export function formatDateFromJSON(
  jsonString: string,
): SafeParseResult<FormatDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatDate' from JSON`,
  );
}

/** @internal */
export const FormatBoolean$inboundSchema: z.ZodType<
  FormatBoolean,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("BOOLEAN"),
});

export function formatBooleanFromJSON(
  jsonString: string,
): SafeParseResult<FormatBoolean, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatBoolean$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatBoolean' from JSON`,
  );
}

/** @internal */
export const DisplayType3$inboundSchema: z.ZodNativeEnum<typeof DisplayType3> =
  z.nativeEnum(DisplayType3);

/** @internal */
export const Option1$inboundSchema: z.ZodType<Option1, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    remote_id: z.nullable(z.string()).optional(),
    name: z.string(),
  });

export function option1FromJSON(
  jsonString: string,
): SafeParseResult<Option1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Option1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Option1' from JSON`,
  );
}

/** @internal */
export const FormatSingleSelect$inboundSchema: z.ZodType<
  FormatSingleSelect,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_type: z.nullable(DisplayType3$inboundSchema).optional(),
  options: z.array(z.lazy(() => Option1$inboundSchema)),
  type: z.literal("SINGLE_SELECT"),
});

export function formatSingleSelectFromJSON(
  jsonString: string,
): SafeParseResult<FormatSingleSelect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatSingleSelect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatSingleSelect' from JSON`,
  );
}

/** @internal */
export const FormatFile$inboundSchema: z.ZodType<
  FormatFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  accepted_mime_types: z.nullable(z.array(z.string())).optional(),
  max_file_size_bytes: z.nullable(z.number().int()).optional(),
  type: z.literal("FILE"),
});

export function formatFileFromJSON(
  jsonString: string,
): SafeParseResult<FormatFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatFile' from JSON`,
  );
}

/** @internal */
export const DisplayType2$inboundSchema: z.ZodNativeEnum<typeof DisplayType2> =
  z.nativeEnum(DisplayType2);

/** @internal */
export const FormatNumber$inboundSchema: z.ZodType<
  FormatNumber,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_type: z.nullable(DisplayType2$inboundSchema.default("FIELD")),
  max: z.nullable(z.number()).optional(),
  min: z.nullable(z.number()).optional(),
  type: z.literal("NUMBER"),
});

export function formatNumberFromJSON(
  jsonString: string,
): SafeParseResult<FormatNumber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatNumber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatNumber' from JSON`,
  );
}

/** @internal */
export const DisplayType1$inboundSchema: z.ZodNativeEnum<typeof DisplayType1> =
  z.nativeEnum(DisplayType1);

/** @internal */
export const FormatText$inboundSchema: z.ZodType<
  FormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_type: z.nullable(DisplayType1$inboundSchema).optional(),
  max_length: z.nullable(z.number().int()).optional(),
  type: z.literal("TEXT"),
});

export function formatTextFromJSON(
  jsonString: string,
): SafeParseResult<FormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatText' from JSON`,
  );
}

/** @internal */
export const Format$inboundSchema: z.ZodType<Format, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => FormatSingleSelect$inboundSchema),
    z.lazy(() => FormatMultiSelect$inboundSchema),
    z.lazy(() => FormatText$inboundSchema),
    z.lazy(() => FormatNumber$inboundSchema),
    z.lazy(() => FormatFile$inboundSchema),
    z.lazy(() => FormatBoolean$inboundSchema),
    z.lazy(() => FormatDate$inboundSchema),
    z.lazy(() => FormatInformation$inboundSchema),
    z.lazy(() => FormatUnknown$inboundSchema),
  ]);

export function formatFromJSON(
  jsonString: string,
): SafeParseResult<Format, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Format$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Format' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseCategory$inboundSchema: z.ZodNativeEnum<
  typeof GetAtsJobsPositiveResponseCategory
> = z.nativeEnum(GetAtsJobsPositiveResponseCategory);

/** @internal */
export const PreconditionOptions$inboundSchema: z.ZodType<
  PreconditionOptions,
  z.ZodTypeDef,
  unknown
> = z.union([z.array(z.string()), z.array(z.boolean())]);

export function preconditionOptionsFromJSON(
  jsonString: string,
): SafeParseResult<PreconditionOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreconditionOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreconditionOptions' from JSON`,
  );
}

/** @internal */
export const ScreeningQuestion$inboundSchema: z.ZodType<
  ScreeningQuestion,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  format: z.nullable(
    z.union([
      z.lazy(() => FormatSingleSelect$inboundSchema),
      z.lazy(() => FormatMultiSelect$inboundSchema),
      z.lazy(() => FormatText$inboundSchema),
      z.lazy(() => FormatNumber$inboundSchema),
      z.lazy(() => FormatFile$inboundSchema),
      z.lazy(() => FormatBoolean$inboundSchema),
      z.lazy(() => FormatDate$inboundSchema),
      z.lazy(() => FormatInformation$inboundSchema),
      z.lazy(() => FormatUnknown$inboundSchema),
    ]),
  ).optional(),
  category: z.nullable(GetAtsJobsPositiveResponseCategory$inboundSchema),
  index: z.nullable(z.number().int()).optional(),
  required: z.nullable(z.boolean()),
  precondition_question_id: z.nullable(z.string()).optional(),
  precondition_options: z.nullable(
    z.union([z.array(z.string()), z.array(z.boolean())]),
  ).optional(),
});

export function screeningQuestionFromJSON(
  jsonString: string,
): SafeParseResult<ScreeningQuestion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScreeningQuestion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScreeningQuestion' from JSON`,
  );
}

/** @internal */
export const JobPostingStatus$inboundSchema: z.ZodNativeEnum<
  typeof JobPostingStatus
> = z.nativeEnum(JobPostingStatus);

/** @internal */
export const JobPostingVisibility$inboundSchema: z.ZodNativeEnum<
  typeof JobPostingVisibility
> = z.nativeEnum(JobPostingVisibility);

/** @internal */
export const JobPosting$inboundSchema: z.ZodType<
  JobPosting,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description_html: z.nullable(z.string()),
  status: z.nullable(JobPostingStatus$inboundSchema),
  visibility: z.nullable(JobPostingVisibility$inboundSchema),
  url: z.nullable(z.string()),
});

export function jobPostingFromJSON(
  jsonString: string,
): SafeParseResult<JobPosting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobPosting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobPosting' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema:
  z.ZodNativeEnum<typeof GetAtsJobsPositiveResponseHiringTeamRole> = z
    .nativeEnum(GetAtsJobsPositiveResponseHiringTeamRole);

/** @internal */
export const GetAtsJobsPositiveResponseHiringTeam$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseHiringTeam,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  email: z.nullable(z.string()).optional(),
  hiring_team_roles: z.array(
    GetAtsJobsPositiveResponseHiringTeamRole$inboundSchema,
  ),
});

export function getAtsJobsPositiveResponseHiringTeamFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseHiringTeam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsJobsPositiveResponseHiringTeam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseHiringTeam' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseResult$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  name: z.nullable(z.string()),
  job_code: z.nullable(z.string()),
  description: z.nullable(z.string()),
  confidential: z.nullable(z.boolean()),
  weekly_hours: z.nullable(z.number()),
  employment_type: z.nullable(
    GetAtsJobsPositiveResponseEmploymentType$inboundSchema,
  ).optional(),
  status: z.nullable(GetAtsJobsPositiveResponseStatus$inboundSchema).optional(),
  visibility: z.nullable(Visibility$inboundSchema).optional(),
  category: z.nullable(z.string()),
  department: z.nullable(z.string()),
  post_url: z.nullable(z.string()),
  experience_level: z.nullable(z.string()),
  remote_work_status: z.nullable(RemoteWorkStatus$inboundSchema).optional(),
  salary_amount: z.nullable(z.number()),
  salary_amount_from: z.nullable(z.number()),
  salary_amount_to: z.nullable(z.number()),
  salary_currency: z.nullable(z.string()),
  salary_period: z.nullable(SalaryPeriod$inboundSchema).optional(),
  location: z.nullable(
    z.lazy(() => GetAtsJobsPositiveResponseLocation$inboundSchema),
  ).optional(),
  custom_fields: z.nullable(z.record(z.any())),
  remote_url: z.nullable(z.string()),
  opened_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  closed_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  contact_id: z.nullable(z.string()),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  stages: z.array(z.lazy(() => Stage$inboundSchema)),
  screening_questions: z.array(z.lazy(() => ScreeningQuestion$inboundSchema)),
  job_postings: z.array(z.lazy(() => JobPosting$inboundSchema)),
  hiring_team: z.array(
    z.lazy(() => GetAtsJobsPositiveResponseHiringTeam$inboundSchema),
  ),
});

export function getAtsJobsPositiveResponseResultFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsJobsPositiveResponseResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseResult' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponseData$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetAtsJobsPositiveResponseResult$inboundSchema),
  ),
});

export function getAtsJobsPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsJobsPositiveResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetAtsJobsPositiveResponse$inboundSchema: z.ZodType<
  GetAtsJobsPositiveResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetAtsJobsPositiveResponseData$inboundSchema),
});

export function getAtsJobsPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsJobsPositiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsJobsPositiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsJobsPositiveResponse' from JSON`,
  );
}
