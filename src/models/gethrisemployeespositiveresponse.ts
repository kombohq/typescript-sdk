/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const GetHrisEmployeesPositiveResponseGender = {
  Male: "MALE",
  Female: "FEMALE",
  NonBinary: "NON_BINARY",
  NotSpecified: "NOT_SPECIFIED",
} as const;
export type GetHrisEmployeesPositiveResponseGender = OpenEnum<
  typeof GetHrisEmployeesPositiveResponseGender
>;

export const Ethnicity = {
  White: "WHITE",
  Asian: "ASIAN",
  HispanicLatino: "HISPANIC_LATINO",
  Hawaiian: "HAWAIIAN",
  NativeAmerican: "NATIVE_AMERICAN",
  BlackAfricanAmerican: "BLACK_AFRICAN_AMERICAN",
  MultipleEthnicities: "MULTIPLE_ETHNICITIES",
  DeclineToSpecify: "DECLINE_TO_SPECIFY",
} as const;
export type Ethnicity = OpenEnum<typeof Ethnicity>;

export const MaritalStatus = {
  Single: "SINGLE",
  Married: "MARRIED",
  DomesticPartnership: "DOMESTIC_PARTNERSHIP",
  Widowed: "WIDOWED",
  Divorced: "DIVORCED",
  Separated: "SEPARATED",
  NotMarried: "NOT_MARRIED",
} as const;
export type MaritalStatus = OpenEnum<typeof MaritalStatus>;

export const EmploymentStatus = {
  Active: "ACTIVE",
  Pending: "PENDING",
  Inactive: "INACTIVE",
  Leave: "LEAVE",
} as const;
export type EmploymentStatus = OpenEnum<typeof EmploymentStatus>;

export const GetHrisEmployeesPositiveResponseEmploymentType = {
  FullTime: "FULL_TIME",
  PartTime: "PART_TIME",
  Contract: "CONTRACT",
  Internship: "INTERNSHIP",
  Freelance: "FREELANCE",
  WorkingStudent: "WORKING_STUDENT",
  Apprenticeship: "APPRENTICESHIP",
  Training: "TRAINING",
} as const;
export type GetHrisEmployeesPositiveResponseEmploymentType = OpenEnum<
  typeof GetHrisEmployeesPositiveResponseEmploymentType
>;

/**
 * The employee’s home address.
 */
export type HomeAddress = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

/**
 * Enum of the routing type, prefixed with the iso-3166-1-alpha-2 banks origin country. If there is uncertainty about the type, it will be set to null.
 */
export const DomesticBankRoutingType = {
  GbSortCode: "GB_SORT_CODE",
  DeBankleitzahl: "DE_BANKLEITZAHL",
  UsAbaRoutingTransitNumber: "US_ABA_ROUTING_TRANSIT_NUMBER",
  CaRoutingNumber: "CA_ROUTING_NUMBER",
  AuBsbCode: "AU_BSB_CODE",
  FrRib: "FR_RIB",
} as const;
/**
 * Enum of the routing type, prefixed with the iso-3166-1-alpha-2 banks origin country. If there is uncertainty about the type, it will be set to null.
 */
export type DomesticBankRoutingType = ClosedEnum<
  typeof DomesticBankRoutingType
>;

export type DomesticBankRouting = {
  /**
   * Bank routing number (e.g. DE Bankleitzahl, GB Sort Code, US ABA routing number, AU BSB code). This field is not formatted and therefore might contain delimiters (eg. 01-23-45).
   */
  number: string;
  /**
   * Enum of the routing type, prefixed with the iso-3166-1-alpha-2 banks origin country. If there is uncertainty about the type, it will be set to null.
   */
  type: DomesticBankRoutingType | null;
};

export type BankAccount = {
  /**
   * The internationally unique IBAN identifying this account. If we detect a valid IBAN from the account number and this field would otherwise be empty, we will automatically populate this field.
   */
  iban?: string | null | undefined;
  /**
   * The internationally unique BIC/SWIFT code identifying the bank behind this account. If we detect a valid BIC from the domestic bank routing number and this field would otherwise be empty, we will automatically populate this field.
   */
  bic?: string | null | undefined;
  /**
   * The bank-specific account number. Some companies use the account number field to put the IBAN here.
   */
  account_number?: string | null | undefined;
  /**
   * The name of the holder of this account.
   */
  holder_name?: string | null | undefined;
  /**
   * The name of the bank behind this account.
   */
  bank_name?: string | null | undefined;
  domestic_bank_routing?: DomesticBankRouting | null | undefined;
};

export const GetHrisEmployeesPositiveResponsePayPeriod = {
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  TwoWeeks: "TWO_WEEKS",
  HalfMonth: "HALF_MONTH",
  Month: "MONTH",
  TwoMonths: "TWO_MONTHS",
  Quarter: "QUARTER",
  HalfYear: "HALF_YEAR",
  Year: "YEAR",
} as const;
export type GetHrisEmployeesPositiveResponsePayPeriod = OpenEnum<
  typeof GetHrisEmployeesPositiveResponsePayPeriod
>;

export const GetHrisEmployeesPositiveResponsePayFrequency = {
  Daily: "DAILY",
  Weekly: "WEEKLY",
  Biweekly: "BIWEEKLY",
  Monthly: "MONTHLY",
  Semimonthly: "SEMIMONTHLY",
  Quarterly: "QUARTERLY",
  Semiannually: "SEMIANNUALLY",
  Annually: "ANNUALLY",
  ProRata: "PRO_RATA",
} as const;
export type GetHrisEmployeesPositiveResponsePayFrequency = OpenEnum<
  typeof GetHrisEmployeesPositiveResponsePayFrequency
>;

export const EmploymentEmploymentType = {
  FullTime: "FULL_TIME",
  PartTime: "PART_TIME",
  Contract: "CONTRACT",
  Internship: "INTERNSHIP",
  Freelance: "FREELANCE",
  WorkingStudent: "WORKING_STUDENT",
  Apprenticeship: "APPRENTICESHIP",
  Training: "TRAINING",
} as const;
export type EmploymentEmploymentType = OpenEnum<
  typeof EmploymentEmploymentType
>;

export type Employment = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The Kombo ID of the employment’s employee. The ID can be used to retrieve the employee from the `get employees` endpoint.
   */
  employee_id: string;
  /**
   * This field can contain historic job titles. Please use the `job_title` field on the employee for the active job title of an employee.
   */
  job_title: string | null;
  /**
   * The monetary amount paid to an employee.
   */
  pay_rate: number | null;
  /**
   * The time interval which the `pay_rate` is describing.
   *
   * @remarks
   *
   * A `pay_rate` value of `12000` with a `pay_period` of `YEAR` would indicate that the employee receives 12000 over the course of a year. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  pay_period?: GetHrisEmployeesPositiveResponsePayPeriod | null | undefined;
  /**
   * The time interval at which the employee receives payment.
   *
   * @remarks
   *
   * A `pay_rate` of `12000`, with a `pay_period` of `YEAR`, and a `pay_frequency` of `MONTHLY` would indicate that the employee is paid 1000 every month. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  pay_frequency?:
    | GetHrisEmployeesPositiveResponsePayFrequency
    | null
    | undefined;
  /**
   * The employee’s current employment type:
   *
   * @remarks
   *
   * - `FULL_TIME`: the employee is actively employed
   * - `PART_TIME`: the employee is working only part of the usual working hours
   * - `CONTRACT`: the employee is working temporarily under a contract
   * - `INTERNSHIP`: the employee is working as an intern
   * - `FREELANCE`: the employee is working as a freelancer
   * - `WORKING_STUDENT`: the employee is working as a working student
   * - `APPRENTICESHIP`: the employee is working in an apprenticeship
   * - `TRAINING`: the employee is working in a training program
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_type?: EmploymentEmploymentType | null | undefined;
  /**
   * The currency that the employee is paid in. Usually returned in [ISO 4217 currency codes](https://www.iso.org/iso-4217-currency-codes.html).
   */
  pay_currency: string | null;
  /**
   * The date of when the employment started.
   */
  effective_date: Date | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
};

/**
 * The time-unit of the balance.
 */
export const GetHrisEmployeesPositiveResponseBalanceUnit = {
  Hours: "HOURS",
  Days: "DAYS",
} as const;
/**
 * The time-unit of the balance.
 */
export type GetHrisEmployeesPositiveResponseBalanceUnit = ClosedEnum<
  typeof GetHrisEmployeesPositiveResponseBalanceUnit
>;

/**
 * The time-unit of the used time.
 */
export const GetHrisEmployeesPositiveResponseUsedUnit = {
  Hours: "HOURS",
  Days: "DAYS",
} as const;
/**
 * The time-unit of the used time.
 */
export type GetHrisEmployeesPositiveResponseUsedUnit = ClosedEnum<
  typeof GetHrisEmployeesPositiveResponseUsedUnit
>;

export type TimeOffBalance = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The Kombo ID of the employee to which the balance belongs to. The ID can be used to retrieve the employee from the `get employees` endpoint.
   */
  employee_id: string;
  type_id: string;
  /**
   * The amount of time available to the employee.
   */
  balance: number | null;
  /**
   * The time-unit of the balance.
   */
  balance_unit: GetHrisEmployeesPositiveResponseBalanceUnit | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * The amount of time used by the employee.
   */
  used: number | null;
  /**
   * The time-unit of the used time.
   */
  used_unit: GetHrisEmployeesPositiveResponseUsedUnit | null;
};

export const ManagerEmploymentStatus = {
  Active: "ACTIVE",
  Pending: "PENDING",
  Inactive: "INACTIVE",
  Leave: "LEAVE",
} as const;
export type ManagerEmploymentStatus = OpenEnum<typeof ManagerEmploymentStatus>;

export type Manager = {
  /**
   * The employee’s first name.
   */
  first_name: string | null;
  /**
   * The employee’s last name.
   */
  last_name: string | null;
  /**
   * The employee’s full name, including any middle names. Not all HR systems provide an explicit display name, so we recommend falling back to `first_name` and `last_name`.
   */
  display_full_name: string | null;
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The employee’s work email address. If the email address is invalid, we will set this to `null`.
   */
  work_email?: string | null | undefined;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * The employee’s current employment status:
   *
   * @remarks
   *
   * - `ACTIVE`: the employee is **actively employed**
   * - `PENDING`: the employee is **not actively employed yet** (but they signed their contract or are part of an onboarding process)
   * - `INACTIVE`: the employee is **not actively employed** anymore
   * - `LEAVE`: the employee is still employed but **currently on leave** (note that not all HR systems support this status — use our absences API for detailed information)
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_status?: ManagerEmploymentStatus | null | undefined;
  /**
   * The date when the employment ends. Can be in the past or future.
   */
  termination_date: Date | null;
};

/**
 * Type of the group.
 */
export const GroupType = {
  Department: "DEPARTMENT",
  Team: "TEAM",
  CostCenter: "COST_CENTER",
} as const;
/**
 * Type of the group.
 */
export type GroupType = ClosedEnum<typeof GroupType>;

export type Group = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * The name of the group.
   */
  name: string | null;
  /**
   * Type of the group.
   */
  type: GroupType | null;
};

/**
 * The legal entity’s address.
 */
export type LegalEntityAddress = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type LegalEntity = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The legal entity’s name.
   */
  name: string | null;
  /**
   * The legal entity’s address.
   */
  address?: LegalEntityAddress | null | undefined;
};

/**
 * The work location’s address
 */
export type WorkLocationAddress = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type WorkLocation = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The work location’s name
   */
  name: string | null;
  /**
   * The work location’s address
   */
  address?: WorkLocationAddress | null | undefined;
  /**
   * The work location’s type. A freeform string.
   */
  type: string | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
};

export type GetHrisEmployeesPositiveResponseResult = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * The employee’s organization-internal employee number.
   */
  employee_number: string | null;
  /**
   * The employee’s first name.
   */
  first_name: string | null;
  /**
   * The employee’s last name.
   */
  last_name: string | null;
  /**
   * The employee’s nationality.
   */
  nationality: string | null;
  /**
   * The employee’s full name, including any middle names. Not all HR systems provide an explicit display name, so we recommend falling back to `first_name` and `last_name`.
   */
  display_full_name: string | null;
  /**
   * The employee’s job title.
   */
  job_title: string | null;
  /**
   * The employee’s work email address. If the email address is invalid, we will set this to `null`.
   */
  work_email?: string | null | undefined;
  /**
   * The employee’s personal email address. If the email address is invalid, we will set this to `null`.
   */
  personal_email?: string | null | undefined;
  /**
   * The employee’s mobile phone number.
   */
  mobile_phone_number: string | null;
  /**
   * The employee’s social security number
   */
  ssn: string | null;
  /**
   * The employee’s tax ID.
   */
  tax_id: string | null;
  /**
   * The employee’s gender.
   */
  gender?: GetHrisEmployeesPositiveResponseGender | null | undefined;
  /**
   * The employee’s ethnicity. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  ethnicity?: Ethnicity | null | undefined;
  /**
   * The employee’s current marital status. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  marital_status?: MaritalStatus | null | undefined;
  /**
   * The employee’s current employment status:
   *
   * @remarks
   *
   * - `ACTIVE`: the employee is **actively employed**
   * - `PENDING`: the employee is **not actively employed yet** (but they signed their contract or are part of an onboarding process)
   * - `INACTIVE`: the employee is **not actively employed** anymore
   * - `LEAVE`: the employee is still employed but **currently on leave** (note that not all HR systems support this status — use our absences API for detailed information)
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_status?: EmploymentStatus | null | undefined;
  /**
   * The employee’s current employment type:
   *
   * @remarks
   *
   * - `FULL_TIME`: the employee is actively employed
   * - `PART_TIME`: the employee is working only part of the usual working hours
   * - `CONTRACT`: the employee is working temporarily under a contract
   * - `INTERNSHIP`: the employee is working as an intern
   * - `FREELANCE`: the employee is working as a freelancer
   * - `WORKING_STUDENT`: the employee is working as a working student
   * - `APPRENTICESHIP`: the employee is working in an apprenticeship
   * - `TRAINING`: the employee is working in a training program
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_type?:
    | GetHrisEmployeesPositiveResponseEmploymentType
    | null
    | undefined;
  /**
   * The employee’s weekly working hours.
   */
  weekly_hours: number | null;
  /**
   * URL to the employee’s avatar. This is either the raw URL from the HR system (in cases where it can be requested without short-lived authentication) _or_ a URL to a temporarily cached version of the file hosted by Kombo. Kombo will delete the cached file after its deletion in the source system.
   */
  avatar: string | null;
  /**
   * The Kombo ID of the employee’s work location. The ID can be used to retrieve the work location from the `get work locations` endpoint.
   */
  work_location_id: string | null;
  /**
   * The Kombo ID of the employee’s legal entity. The ID can be used to retrieve the legal entity from the `get legal entities` endpoint.
   */
  legal_entity_id: string | null;
  /**
   * The Kombo ID of the employee’s manager. The ID can be used to retrieve the manager from the `get employees` endpoint.
   */
  manager_id: string | null;
  /**
   * The employee’s home address.
   */
  home_address?: HomeAddress | null | undefined;
  /**
   * The employee’s bank accounts.
   */
  bank_accounts?: Array<BankAccount> | null | undefined;
  /**
   * The employee’s date of birth.
   */
  date_of_birth: Date | null;
  /**
   * The date the employee started working for the organization.
   */
  start_date: Date | null;
  /**
   * The date when the employment ends. Can be in the past or future.
   */
  termination_date: Date | null;
  /**
   * The date and time the object was created in the remote system.
   */
  remote_created_at: Date | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
  employments: Array<Employment>;
  time_off_balances: Array<TimeOffBalance>;
  manager: Manager | null;
  groups: Array<Group>;
  legal_entity: LegalEntity | null;
  work_location: WorkLocation | null;
};

export type GetHrisEmployeesPositiveResponseData = {
  /**
   * Cursor string that can be passed to the `cursor` query parameter to get the next page. If this is `null`, then there are no more pages.
   */
  next: string | null;
  results: Array<GetHrisEmployeesPositiveResponseResult>;
};

export type GetHrisEmployeesPositiveResponse = {
  status: "success";
  data: GetHrisEmployeesPositiveResponseData;
};

/** @internal */
export const GetHrisEmployeesPositiveResponseGender$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseGender,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetHrisEmployeesPositiveResponseGender),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetHrisEmployeesPositiveResponseGender$outboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseGender,
  z.ZodTypeDef,
  GetHrisEmployeesPositiveResponseGender
> = z.union([
  z.nativeEnum(GetHrisEmployeesPositiveResponseGender),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponseGender$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponseGender$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponseGender$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseGender$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponseGender$outboundSchema;
}

/** @internal */
export const Ethnicity$inboundSchema: z.ZodType<
  Ethnicity,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Ethnicity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Ethnicity$outboundSchema: z.ZodType<
  Ethnicity,
  z.ZodTypeDef,
  Ethnicity
> = z.union([
  z.nativeEnum(Ethnicity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ethnicity$ {
  /** @deprecated use `Ethnicity$inboundSchema` instead. */
  export const inboundSchema = Ethnicity$inboundSchema;
  /** @deprecated use `Ethnicity$outboundSchema` instead. */
  export const outboundSchema = Ethnicity$outboundSchema;
}

/** @internal */
export const MaritalStatus$inboundSchema: z.ZodType<
  MaritalStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MaritalStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MaritalStatus$outboundSchema: z.ZodType<
  MaritalStatus,
  z.ZodTypeDef,
  MaritalStatus
> = z.union([
  z.nativeEnum(MaritalStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaritalStatus$ {
  /** @deprecated use `MaritalStatus$inboundSchema` instead. */
  export const inboundSchema = MaritalStatus$inboundSchema;
  /** @deprecated use `MaritalStatus$outboundSchema` instead. */
  export const outboundSchema = MaritalStatus$outboundSchema;
}

/** @internal */
export const EmploymentStatus$inboundSchema: z.ZodType<
  EmploymentStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EmploymentStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EmploymentStatus$outboundSchema: z.ZodType<
  EmploymentStatus,
  z.ZodTypeDef,
  EmploymentStatus
> = z.union([
  z.nativeEnum(EmploymentStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmploymentStatus$ {
  /** @deprecated use `EmploymentStatus$inboundSchema` instead. */
  export const inboundSchema = EmploymentStatus$inboundSchema;
  /** @deprecated use `EmploymentStatus$outboundSchema` instead. */
  export const outboundSchema = EmploymentStatus$outboundSchema;
}

/** @internal */
export const GetHrisEmployeesPositiveResponseEmploymentType$inboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponseEmploymentType,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(GetHrisEmployeesPositiveResponseEmploymentType),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const GetHrisEmployeesPositiveResponseEmploymentType$outboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponseEmploymentType,
    z.ZodTypeDef,
    GetHrisEmployeesPositiveResponseEmploymentType
  > = z.union([
    z.nativeEnum(GetHrisEmployeesPositiveResponseEmploymentType),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponseEmploymentType$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponseEmploymentType$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponseEmploymentType$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseEmploymentType$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponseEmploymentType$outboundSchema;
}

/** @internal */
export const HomeAddress$inboundSchema: z.ZodType<
  HomeAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/** @internal */
export type HomeAddress$Outbound = {
  city?: string | null | undefined;
  country?: string | null | undefined;
  raw?: string | null | undefined;
  state?: string | null | undefined;
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

/** @internal */
export const HomeAddress$outboundSchema: z.ZodType<
  HomeAddress$Outbound,
  z.ZodTypeDef,
  HomeAddress
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HomeAddress$ {
  /** @deprecated use `HomeAddress$inboundSchema` instead. */
  export const inboundSchema = HomeAddress$inboundSchema;
  /** @deprecated use `HomeAddress$outboundSchema` instead. */
  export const outboundSchema = HomeAddress$outboundSchema;
  /** @deprecated use `HomeAddress$Outbound` instead. */
  export type Outbound = HomeAddress$Outbound;
}

export function homeAddressToJSON(homeAddress: HomeAddress): string {
  return JSON.stringify(HomeAddress$outboundSchema.parse(homeAddress));
}

export function homeAddressFromJSON(
  jsonString: string,
): SafeParseResult<HomeAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HomeAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HomeAddress' from JSON`,
  );
}

/** @internal */
export const DomesticBankRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof DomesticBankRoutingType
> = z.nativeEnum(DomesticBankRoutingType);

/** @internal */
export const DomesticBankRoutingType$outboundSchema: z.ZodNativeEnum<
  typeof DomesticBankRoutingType
> = DomesticBankRoutingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DomesticBankRoutingType$ {
  /** @deprecated use `DomesticBankRoutingType$inboundSchema` instead. */
  export const inboundSchema = DomesticBankRoutingType$inboundSchema;
  /** @deprecated use `DomesticBankRoutingType$outboundSchema` instead. */
  export const outboundSchema = DomesticBankRoutingType$outboundSchema;
}

/** @internal */
export const DomesticBankRouting$inboundSchema: z.ZodType<
  DomesticBankRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  number: z.string(),
  type: z.nullable(DomesticBankRoutingType$inboundSchema),
});

/** @internal */
export type DomesticBankRouting$Outbound = {
  number: string;
  type: string | null;
};

/** @internal */
export const DomesticBankRouting$outboundSchema: z.ZodType<
  DomesticBankRouting$Outbound,
  z.ZodTypeDef,
  DomesticBankRouting
> = z.object({
  number: z.string(),
  type: z.nullable(DomesticBankRoutingType$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DomesticBankRouting$ {
  /** @deprecated use `DomesticBankRouting$inboundSchema` instead. */
  export const inboundSchema = DomesticBankRouting$inboundSchema;
  /** @deprecated use `DomesticBankRouting$outboundSchema` instead. */
  export const outboundSchema = DomesticBankRouting$outboundSchema;
  /** @deprecated use `DomesticBankRouting$Outbound` instead. */
  export type Outbound = DomesticBankRouting$Outbound;
}

export function domesticBankRoutingToJSON(
  domesticBankRouting: DomesticBankRouting,
): string {
  return JSON.stringify(
    DomesticBankRouting$outboundSchema.parse(domesticBankRouting),
  );
}

export function domesticBankRoutingFromJSON(
  jsonString: string,
): SafeParseResult<DomesticBankRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DomesticBankRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DomesticBankRouting' from JSON`,
  );
}

/** @internal */
export const BankAccount$inboundSchema: z.ZodType<
  BankAccount,
  z.ZodTypeDef,
  unknown
> = z.object({
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  account_number: z.nullable(z.string()).optional(),
  holder_name: z.nullable(z.string()).optional(),
  bank_name: z.nullable(z.string()).optional(),
  domestic_bank_routing: z.nullable(
    z.lazy(() => DomesticBankRouting$inboundSchema),
  ).optional(),
});

/** @internal */
export type BankAccount$Outbound = {
  iban?: string | null | undefined;
  bic?: string | null | undefined;
  account_number?: string | null | undefined;
  holder_name?: string | null | undefined;
  bank_name?: string | null | undefined;
  domestic_bank_routing?: DomesticBankRouting$Outbound | null | undefined;
};

/** @internal */
export const BankAccount$outboundSchema: z.ZodType<
  BankAccount$Outbound,
  z.ZodTypeDef,
  BankAccount
> = z.object({
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  account_number: z.nullable(z.string()).optional(),
  holder_name: z.nullable(z.string()).optional(),
  bank_name: z.nullable(z.string()).optional(),
  domestic_bank_routing: z.nullable(
    z.lazy(() => DomesticBankRouting$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BankAccount$ {
  /** @deprecated use `BankAccount$inboundSchema` instead. */
  export const inboundSchema = BankAccount$inboundSchema;
  /** @deprecated use `BankAccount$outboundSchema` instead. */
  export const outboundSchema = BankAccount$outboundSchema;
  /** @deprecated use `BankAccount$Outbound` instead. */
  export type Outbound = BankAccount$Outbound;
}

export function bankAccountToJSON(bankAccount: BankAccount): string {
  return JSON.stringify(BankAccount$outboundSchema.parse(bankAccount));
}

export function bankAccountFromJSON(
  jsonString: string,
): SafeParseResult<BankAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BankAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BankAccount' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponsePayPeriod$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponsePayPeriod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetHrisEmployeesPositiveResponsePayPeriod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetHrisEmployeesPositiveResponsePayPeriod$outboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponsePayPeriod,
    z.ZodTypeDef,
    GetHrisEmployeesPositiveResponsePayPeriod
  > = z.union([
    z.nativeEnum(GetHrisEmployeesPositiveResponsePayPeriod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponsePayPeriod$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponsePayPeriod$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponsePayPeriod$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponsePayPeriod$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponsePayPeriod$outboundSchema;
}

/** @internal */
export const GetHrisEmployeesPositiveResponsePayFrequency$inboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponsePayFrequency,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(GetHrisEmployeesPositiveResponsePayFrequency),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const GetHrisEmployeesPositiveResponsePayFrequency$outboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponsePayFrequency,
    z.ZodTypeDef,
    GetHrisEmployeesPositiveResponsePayFrequency
  > = z.union([
    z.nativeEnum(GetHrisEmployeesPositiveResponsePayFrequency),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponsePayFrequency$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponsePayFrequency$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponsePayFrequency$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponsePayFrequency$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponsePayFrequency$outboundSchema;
}

/** @internal */
export const EmploymentEmploymentType$inboundSchema: z.ZodType<
  EmploymentEmploymentType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EmploymentEmploymentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EmploymentEmploymentType$outboundSchema: z.ZodType<
  EmploymentEmploymentType,
  z.ZodTypeDef,
  EmploymentEmploymentType
> = z.union([
  z.nativeEnum(EmploymentEmploymentType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmploymentEmploymentType$ {
  /** @deprecated use `EmploymentEmploymentType$inboundSchema` instead. */
  export const inboundSchema = EmploymentEmploymentType$inboundSchema;
  /** @deprecated use `EmploymentEmploymentType$outboundSchema` instead. */
  export const outboundSchema = EmploymentEmploymentType$outboundSchema;
}

/** @internal */
export const Employment$inboundSchema: z.ZodType<
  Employment,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  job_title: z.nullable(z.string()),
  pay_rate: z.nullable(z.number()),
  pay_period: z.nullable(
    GetHrisEmployeesPositiveResponsePayPeriod$inboundSchema,
  ).optional(),
  pay_frequency: z.nullable(
    GetHrisEmployeesPositiveResponsePayFrequency$inboundSchema,
  ).optional(),
  employment_type: z.nullable(EmploymentEmploymentType$inboundSchema)
    .optional(),
  pay_currency: z.nullable(z.string()),
  effective_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  custom_fields: z.nullable(z.record(z.any())),
});

/** @internal */
export type Employment$Outbound = {
  id: string;
  remote_id: string | null;
  employee_id: string;
  job_title: string | null;
  pay_rate: number | null;
  pay_period?: string | null | undefined;
  pay_frequency?: string | null | undefined;
  employment_type?: string | null | undefined;
  pay_currency: string | null;
  effective_date: string | null;
  changed_at: string;
  remote_deleted_at: string | null;
  custom_fields: { [k: string]: any } | null;
};

/** @internal */
export const Employment$outboundSchema: z.ZodType<
  Employment$Outbound,
  z.ZodTypeDef,
  Employment
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  job_title: z.nullable(z.string()),
  pay_rate: z.nullable(z.number()),
  pay_period: z.nullable(
    GetHrisEmployeesPositiveResponsePayPeriod$outboundSchema,
  ).optional(),
  pay_frequency: z.nullable(
    GetHrisEmployeesPositiveResponsePayFrequency$outboundSchema,
  ).optional(),
  employment_type: z.nullable(EmploymentEmploymentType$outboundSchema)
    .optional(),
  pay_currency: z.nullable(z.string()),
  effective_date: z.nullable(z.date().transform(v => v.toISOString())),
  changed_at: z.date().transform(v => v.toISOString()),
  remote_deleted_at: z.nullable(z.date().transform(v => v.toISOString())),
  custom_fields: z.nullable(z.record(z.any())),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Employment$ {
  /** @deprecated use `Employment$inboundSchema` instead. */
  export const inboundSchema = Employment$inboundSchema;
  /** @deprecated use `Employment$outboundSchema` instead. */
  export const outboundSchema = Employment$outboundSchema;
  /** @deprecated use `Employment$Outbound` instead. */
  export type Outbound = Employment$Outbound;
}

export function employmentToJSON(employment: Employment): string {
  return JSON.stringify(Employment$outboundSchema.parse(employment));
}

export function employmentFromJSON(
  jsonString: string,
): SafeParseResult<Employment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Employment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Employment' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema:
  z.ZodNativeEnum<typeof GetHrisEmployeesPositiveResponseBalanceUnit> = z
    .nativeEnum(GetHrisEmployeesPositiveResponseBalanceUnit);

/** @internal */
export const GetHrisEmployeesPositiveResponseBalanceUnit$outboundSchema:
  z.ZodNativeEnum<typeof GetHrisEmployeesPositiveResponseBalanceUnit> =
    GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponseBalanceUnit$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseBalanceUnit$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponseBalanceUnit$outboundSchema;
}

/** @internal */
export const GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema:
  z.ZodNativeEnum<typeof GetHrisEmployeesPositiveResponseUsedUnit> = z
    .nativeEnum(GetHrisEmployeesPositiveResponseUsedUnit);

/** @internal */
export const GetHrisEmployeesPositiveResponseUsedUnit$outboundSchema:
  z.ZodNativeEnum<typeof GetHrisEmployeesPositiveResponseUsedUnit> =
    GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponseUsedUnit$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseUsedUnit$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponseUsedUnit$outboundSchema;
}

/** @internal */
export const TimeOffBalance$inboundSchema: z.ZodType<
  TimeOffBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  type_id: z.string(),
  balance: z.nullable(z.number()),
  balance_unit: z.nullable(
    GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema,
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  used: z.nullable(z.number()),
  used_unit: z.nullable(GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema),
});

/** @internal */
export type TimeOffBalance$Outbound = {
  id: string;
  remote_id: string | null;
  employee_id: string;
  type_id: string;
  balance: number | null;
  balance_unit: string | null;
  changed_at: string;
  remote_deleted_at: string | null;
  used: number | null;
  used_unit: string | null;
};

/** @internal */
export const TimeOffBalance$outboundSchema: z.ZodType<
  TimeOffBalance$Outbound,
  z.ZodTypeDef,
  TimeOffBalance
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  type_id: z.string(),
  balance: z.nullable(z.number()),
  balance_unit: z.nullable(
    GetHrisEmployeesPositiveResponseBalanceUnit$outboundSchema,
  ),
  changed_at: z.date().transform(v => v.toISOString()),
  remote_deleted_at: z.nullable(z.date().transform(v => v.toISOString())),
  used: z.nullable(z.number()),
  used_unit: z.nullable(
    GetHrisEmployeesPositiveResponseUsedUnit$outboundSchema,
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeOffBalance$ {
  /** @deprecated use `TimeOffBalance$inboundSchema` instead. */
  export const inboundSchema = TimeOffBalance$inboundSchema;
  /** @deprecated use `TimeOffBalance$outboundSchema` instead. */
  export const outboundSchema = TimeOffBalance$outboundSchema;
  /** @deprecated use `TimeOffBalance$Outbound` instead. */
  export type Outbound = TimeOffBalance$Outbound;
}

export function timeOffBalanceToJSON(timeOffBalance: TimeOffBalance): string {
  return JSON.stringify(TimeOffBalance$outboundSchema.parse(timeOffBalance));
}

export function timeOffBalanceFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalance' from JSON`,
  );
}

/** @internal */
export const ManagerEmploymentStatus$inboundSchema: z.ZodType<
  ManagerEmploymentStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ManagerEmploymentStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ManagerEmploymentStatus$outboundSchema: z.ZodType<
  ManagerEmploymentStatus,
  z.ZodTypeDef,
  ManagerEmploymentStatus
> = z.union([
  z.nativeEnum(ManagerEmploymentStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ManagerEmploymentStatus$ {
  /** @deprecated use `ManagerEmploymentStatus$inboundSchema` instead. */
  export const inboundSchema = ManagerEmploymentStatus$inboundSchema;
  /** @deprecated use `ManagerEmploymentStatus$outboundSchema` instead. */
  export const outboundSchema = ManagerEmploymentStatus$outboundSchema;
}

/** @internal */
export const Manager$inboundSchema: z.ZodType<Manager, z.ZodTypeDef, unknown> =
  z.object({
    first_name: z.nullable(z.string()),
    last_name: z.nullable(z.string()),
    display_full_name: z.nullable(z.string()),
    id: z.string(),
    work_email: z.nullable(z.string()).optional(),
    remote_id: z.string(),
    employment_status: z.nullable(ManagerEmploymentStatus$inboundSchema)
      .optional(),
    termination_date: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ),
  });

/** @internal */
export type Manager$Outbound = {
  first_name: string | null;
  last_name: string | null;
  display_full_name: string | null;
  id: string;
  work_email?: string | null | undefined;
  remote_id: string;
  employment_status?: string | null | undefined;
  termination_date: string | null;
};

/** @internal */
export const Manager$outboundSchema: z.ZodType<
  Manager$Outbound,
  z.ZodTypeDef,
  Manager
> = z.object({
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  display_full_name: z.nullable(z.string()),
  id: z.string(),
  work_email: z.nullable(z.string()).optional(),
  remote_id: z.string(),
  employment_status: z.nullable(ManagerEmploymentStatus$outboundSchema)
    .optional(),
  termination_date: z.nullable(z.date().transform(v => v.toISOString())),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Manager$ {
  /** @deprecated use `Manager$inboundSchema` instead. */
  export const inboundSchema = Manager$inboundSchema;
  /** @deprecated use `Manager$outboundSchema` instead. */
  export const outboundSchema = Manager$outboundSchema;
  /** @deprecated use `Manager$Outbound` instead. */
  export type Outbound = Manager$Outbound;
}

export function managerToJSON(manager: Manager): string {
  return JSON.stringify(Manager$outboundSchema.parse(manager));
}

export function managerFromJSON(
  jsonString: string,
): SafeParseResult<Manager, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Manager$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Manager' from JSON`,
  );
}

/** @internal */
export const GroupType$inboundSchema: z.ZodNativeEnum<typeof GroupType> = z
  .nativeEnum(GroupType);

/** @internal */
export const GroupType$outboundSchema: z.ZodNativeEnum<typeof GroupType> =
  GroupType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GroupType$ {
  /** @deprecated use `GroupType$inboundSchema` instead. */
  export const inboundSchema = GroupType$inboundSchema;
  /** @deprecated use `GroupType$outboundSchema` instead. */
  export const outboundSchema = GroupType$outboundSchema;
}

/** @internal */
export const Group$inboundSchema: z.ZodType<Group, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    remote_id: z.string(),
    name: z.nullable(z.string()),
    type: z.nullable(GroupType$inboundSchema),
  });

/** @internal */
export type Group$Outbound = {
  id: string;
  remote_id: string;
  name: string | null;
  type: string | null;
};

/** @internal */
export const Group$outboundSchema: z.ZodType<
  Group$Outbound,
  z.ZodTypeDef,
  Group
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  name: z.nullable(z.string()),
  type: z.nullable(GroupType$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Group$ {
  /** @deprecated use `Group$inboundSchema` instead. */
  export const inboundSchema = Group$inboundSchema;
  /** @deprecated use `Group$outboundSchema` instead. */
  export const outboundSchema = Group$outboundSchema;
  /** @deprecated use `Group$Outbound` instead. */
  export type Outbound = Group$Outbound;
}

export function groupToJSON(group: Group): string {
  return JSON.stringify(Group$outboundSchema.parse(group));
}

export function groupFromJSON(
  jsonString: string,
): SafeParseResult<Group, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Group$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Group' from JSON`,
  );
}

/** @internal */
export const LegalEntityAddress$inboundSchema: z.ZodType<
  LegalEntityAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/** @internal */
export type LegalEntityAddress$Outbound = {
  city?: string | null | undefined;
  country?: string | null | undefined;
  raw?: string | null | undefined;
  state?: string | null | undefined;
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

/** @internal */
export const LegalEntityAddress$outboundSchema: z.ZodType<
  LegalEntityAddress$Outbound,
  z.ZodTypeDef,
  LegalEntityAddress
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LegalEntityAddress$ {
  /** @deprecated use `LegalEntityAddress$inboundSchema` instead. */
  export const inboundSchema = LegalEntityAddress$inboundSchema;
  /** @deprecated use `LegalEntityAddress$outboundSchema` instead. */
  export const outboundSchema = LegalEntityAddress$outboundSchema;
  /** @deprecated use `LegalEntityAddress$Outbound` instead. */
  export type Outbound = LegalEntityAddress$Outbound;
}

export function legalEntityAddressToJSON(
  legalEntityAddress: LegalEntityAddress,
): string {
  return JSON.stringify(
    LegalEntityAddress$outboundSchema.parse(legalEntityAddress),
  );
}

export function legalEntityAddressFromJSON(
  jsonString: string,
): SafeParseResult<LegalEntityAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LegalEntityAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LegalEntityAddress' from JSON`,
  );
}

/** @internal */
export const LegalEntity$inboundSchema: z.ZodType<
  LegalEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  address: z.nullable(z.lazy(() => LegalEntityAddress$inboundSchema))
    .optional(),
});

/** @internal */
export type LegalEntity$Outbound = {
  id: string;
  remote_id: string | null;
  name: string | null;
  address?: LegalEntityAddress$Outbound | null | undefined;
};

/** @internal */
export const LegalEntity$outboundSchema: z.ZodType<
  LegalEntity$Outbound,
  z.ZodTypeDef,
  LegalEntity
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  address: z.nullable(z.lazy(() => LegalEntityAddress$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LegalEntity$ {
  /** @deprecated use `LegalEntity$inboundSchema` instead. */
  export const inboundSchema = LegalEntity$inboundSchema;
  /** @deprecated use `LegalEntity$outboundSchema` instead. */
  export const outboundSchema = LegalEntity$outboundSchema;
  /** @deprecated use `LegalEntity$Outbound` instead. */
  export type Outbound = LegalEntity$Outbound;
}

export function legalEntityToJSON(legalEntity: LegalEntity): string {
  return JSON.stringify(LegalEntity$outboundSchema.parse(legalEntity));
}

export function legalEntityFromJSON(
  jsonString: string,
): SafeParseResult<LegalEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LegalEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LegalEntity' from JSON`,
  );
}

/** @internal */
export const WorkLocationAddress$inboundSchema: z.ZodType<
  WorkLocationAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/** @internal */
export type WorkLocationAddress$Outbound = {
  city?: string | null | undefined;
  country?: string | null | undefined;
  raw?: string | null | undefined;
  state?: string | null | undefined;
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

/** @internal */
export const WorkLocationAddress$outboundSchema: z.ZodType<
  WorkLocationAddress$Outbound,
  z.ZodTypeDef,
  WorkLocationAddress
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkLocationAddress$ {
  /** @deprecated use `WorkLocationAddress$inboundSchema` instead. */
  export const inboundSchema = WorkLocationAddress$inboundSchema;
  /** @deprecated use `WorkLocationAddress$outboundSchema` instead. */
  export const outboundSchema = WorkLocationAddress$outboundSchema;
  /** @deprecated use `WorkLocationAddress$Outbound` instead. */
  export type Outbound = WorkLocationAddress$Outbound;
}

export function workLocationAddressToJSON(
  workLocationAddress: WorkLocationAddress,
): string {
  return JSON.stringify(
    WorkLocationAddress$outboundSchema.parse(workLocationAddress),
  );
}

export function workLocationAddressFromJSON(
  jsonString: string,
): SafeParseResult<WorkLocationAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkLocationAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkLocationAddress' from JSON`,
  );
}

/** @internal */
export const WorkLocation$inboundSchema: z.ZodType<
  WorkLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  address: z.nullable(z.lazy(() => WorkLocationAddress$inboundSchema))
    .optional(),
  type: z.nullable(z.string()),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
});

/** @internal */
export type WorkLocation$Outbound = {
  id: string;
  remote_id: string | null;
  name: string | null;
  address?: WorkLocationAddress$Outbound | null | undefined;
  type: string | null;
  changed_at: string;
  remote_deleted_at: string | null;
};

/** @internal */
export const WorkLocation$outboundSchema: z.ZodType<
  WorkLocation$Outbound,
  z.ZodTypeDef,
  WorkLocation
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  address: z.nullable(z.lazy(() => WorkLocationAddress$outboundSchema))
    .optional(),
  type: z.nullable(z.string()),
  changed_at: z.date().transform(v => v.toISOString()),
  remote_deleted_at: z.nullable(z.date().transform(v => v.toISOString())),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkLocation$ {
  /** @deprecated use `WorkLocation$inboundSchema` instead. */
  export const inboundSchema = WorkLocation$inboundSchema;
  /** @deprecated use `WorkLocation$outboundSchema` instead. */
  export const outboundSchema = WorkLocation$outboundSchema;
  /** @deprecated use `WorkLocation$Outbound` instead. */
  export type Outbound = WorkLocation$Outbound;
}

export function workLocationToJSON(workLocation: WorkLocation): string {
  return JSON.stringify(WorkLocation$outboundSchema.parse(workLocation));
}

export function workLocationFromJSON(
  jsonString: string,
): SafeParseResult<WorkLocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkLocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkLocation' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponseResult$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  employee_number: z.nullable(z.string()),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  nationality: z.nullable(z.string()),
  display_full_name: z.nullable(z.string()),
  job_title: z.nullable(z.string()),
  work_email: z.nullable(z.string()).optional(),
  personal_email: z.nullable(z.string()).optional(),
  mobile_phone_number: z.nullable(z.string()),
  ssn: z.nullable(z.string()),
  tax_id: z.nullable(z.string()),
  gender: z.nullable(GetHrisEmployeesPositiveResponseGender$inboundSchema)
    .optional(),
  ethnicity: z.nullable(Ethnicity$inboundSchema).optional(),
  marital_status: z.nullable(MaritalStatus$inboundSchema).optional(),
  employment_status: z.nullable(EmploymentStatus$inboundSchema).optional(),
  employment_type: z.nullable(
    GetHrisEmployeesPositiveResponseEmploymentType$inboundSchema,
  ).optional(),
  weekly_hours: z.nullable(z.number()),
  avatar: z.nullable(z.string()),
  work_location_id: z.nullable(z.string()),
  legal_entity_id: z.nullable(z.string()),
  manager_id: z.nullable(z.string()),
  home_address: z.nullable(z.lazy(() => HomeAddress$inboundSchema)).optional(),
  bank_accounts: z.nullable(z.array(z.lazy(() => BankAccount$inboundSchema)))
    .optional(),
  date_of_birth: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  start_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  termination_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  custom_fields: z.nullable(z.record(z.any())),
  employments: z.array(z.lazy(() => Employment$inboundSchema)),
  time_off_balances: z.array(z.lazy(() => TimeOffBalance$inboundSchema)),
  manager: z.nullable(z.lazy(() => Manager$inboundSchema)),
  groups: z.array(z.lazy(() => Group$inboundSchema)),
  legal_entity: z.nullable(z.lazy(() => LegalEntity$inboundSchema)),
  work_location: z.nullable(z.lazy(() => WorkLocation$inboundSchema)),
});

/** @internal */
export type GetHrisEmployeesPositiveResponseResult$Outbound = {
  id: string;
  remote_id: string;
  employee_number: string | null;
  first_name: string | null;
  last_name: string | null;
  nationality: string | null;
  display_full_name: string | null;
  job_title: string | null;
  work_email?: string | null | undefined;
  personal_email?: string | null | undefined;
  mobile_phone_number: string | null;
  ssn: string | null;
  tax_id: string | null;
  gender?: string | null | undefined;
  ethnicity?: string | null | undefined;
  marital_status?: string | null | undefined;
  employment_status?: string | null | undefined;
  employment_type?: string | null | undefined;
  weekly_hours: number | null;
  avatar: string | null;
  work_location_id: string | null;
  legal_entity_id: string | null;
  manager_id: string | null;
  home_address?: HomeAddress$Outbound | null | undefined;
  bank_accounts?: Array<BankAccount$Outbound> | null | undefined;
  date_of_birth: string | null;
  start_date: string | null;
  termination_date: string | null;
  remote_created_at: string | null;
  changed_at: string;
  remote_deleted_at: string | null;
  custom_fields: { [k: string]: any } | null;
  employments: Array<Employment$Outbound>;
  time_off_balances: Array<TimeOffBalance$Outbound>;
  manager: Manager$Outbound | null;
  groups: Array<Group$Outbound>;
  legal_entity: LegalEntity$Outbound | null;
  work_location: WorkLocation$Outbound | null;
};

/** @internal */
export const GetHrisEmployeesPositiveResponseResult$outboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseResult$Outbound,
  z.ZodTypeDef,
  GetHrisEmployeesPositiveResponseResult
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  employee_number: z.nullable(z.string()),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  nationality: z.nullable(z.string()),
  display_full_name: z.nullable(z.string()),
  job_title: z.nullable(z.string()),
  work_email: z.nullable(z.string()).optional(),
  personal_email: z.nullable(z.string()).optional(),
  mobile_phone_number: z.nullable(z.string()),
  ssn: z.nullable(z.string()),
  tax_id: z.nullable(z.string()),
  gender: z.nullable(GetHrisEmployeesPositiveResponseGender$outboundSchema)
    .optional(),
  ethnicity: z.nullable(Ethnicity$outboundSchema).optional(),
  marital_status: z.nullable(MaritalStatus$outboundSchema).optional(),
  employment_status: z.nullable(EmploymentStatus$outboundSchema).optional(),
  employment_type: z.nullable(
    GetHrisEmployeesPositiveResponseEmploymentType$outboundSchema,
  ).optional(),
  weekly_hours: z.nullable(z.number()),
  avatar: z.nullable(z.string()),
  work_location_id: z.nullable(z.string()),
  legal_entity_id: z.nullable(z.string()),
  manager_id: z.nullable(z.string()),
  home_address: z.nullable(z.lazy(() => HomeAddress$outboundSchema)).optional(),
  bank_accounts: z.nullable(z.array(z.lazy(() => BankAccount$outboundSchema)))
    .optional(),
  date_of_birth: z.nullable(z.date().transform(v => v.toISOString())),
  start_date: z.nullable(z.date().transform(v => v.toISOString())),
  termination_date: z.nullable(z.date().transform(v => v.toISOString())),
  remote_created_at: z.nullable(z.date().transform(v => v.toISOString())),
  changed_at: z.date().transform(v => v.toISOString()),
  remote_deleted_at: z.nullable(z.date().transform(v => v.toISOString())),
  custom_fields: z.nullable(z.record(z.any())),
  employments: z.array(z.lazy(() => Employment$outboundSchema)),
  time_off_balances: z.array(z.lazy(() => TimeOffBalance$outboundSchema)),
  manager: z.nullable(z.lazy(() => Manager$outboundSchema)),
  groups: z.array(z.lazy(() => Group$outboundSchema)),
  legal_entity: z.nullable(z.lazy(() => LegalEntity$outboundSchema)),
  work_location: z.nullable(z.lazy(() => WorkLocation$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponseResult$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponseResult$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponseResult$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseResult$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponseResult$outboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseResult$Outbound` instead. */
  export type Outbound = GetHrisEmployeesPositiveResponseResult$Outbound;
}

export function getHrisEmployeesPositiveResponseResultToJSON(
  getHrisEmployeesPositiveResponseResult:
    GetHrisEmployeesPositiveResponseResult,
): string {
  return JSON.stringify(
    GetHrisEmployeesPositiveResponseResult$outboundSchema.parse(
      getHrisEmployeesPositiveResponseResult,
    ),
  );
}

export function getHrisEmployeesPositiveResponseResultFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisEmployeesPositiveResponseResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetHrisEmployeesPositiveResponseResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisEmployeesPositiveResponseResult' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponseData$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetHrisEmployeesPositiveResponseResult$inboundSchema),
  ),
});

/** @internal */
export type GetHrisEmployeesPositiveResponseData$Outbound = {
  next: string | null;
  results: Array<GetHrisEmployeesPositiveResponseResult$Outbound>;
};

/** @internal */
export const GetHrisEmployeesPositiveResponseData$outboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseData$Outbound,
  z.ZodTypeDef,
  GetHrisEmployeesPositiveResponseData
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetHrisEmployeesPositiveResponseResult$outboundSchema),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponseData$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponseData$inboundSchema` instead. */
  export const inboundSchema =
    GetHrisEmployeesPositiveResponseData$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseData$outboundSchema` instead. */
  export const outboundSchema =
    GetHrisEmployeesPositiveResponseData$outboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponseData$Outbound` instead. */
  export type Outbound = GetHrisEmployeesPositiveResponseData$Outbound;
}

export function getHrisEmployeesPositiveResponseDataToJSON(
  getHrisEmployeesPositiveResponseData: GetHrisEmployeesPositiveResponseData,
): string {
  return JSON.stringify(
    GetHrisEmployeesPositiveResponseData$outboundSchema.parse(
      getHrisEmployeesPositiveResponseData,
    ),
  );
}

export function getHrisEmployeesPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisEmployeesPositiveResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetHrisEmployeesPositiveResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisEmployeesPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponse$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetHrisEmployeesPositiveResponseData$inboundSchema),
});

/** @internal */
export type GetHrisEmployeesPositiveResponse$Outbound = {
  status: "success";
  data: GetHrisEmployeesPositiveResponseData$Outbound;
};

/** @internal */
export const GetHrisEmployeesPositiveResponse$outboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponse$Outbound,
  z.ZodTypeDef,
  GetHrisEmployeesPositiveResponse
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetHrisEmployeesPositiveResponseData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetHrisEmployeesPositiveResponse$ {
  /** @deprecated use `GetHrisEmployeesPositiveResponse$inboundSchema` instead. */
  export const inboundSchema = GetHrisEmployeesPositiveResponse$inboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponse$outboundSchema` instead. */
  export const outboundSchema = GetHrisEmployeesPositiveResponse$outboundSchema;
  /** @deprecated use `GetHrisEmployeesPositiveResponse$Outbound` instead. */
  export type Outbound = GetHrisEmployeesPositiveResponse$Outbound;
}

export function getHrisEmployeesPositiveResponseToJSON(
  getHrisEmployeesPositiveResponse: GetHrisEmployeesPositiveResponse,
): string {
  return JSON.stringify(
    GetHrisEmployeesPositiveResponse$outboundSchema.parse(
      getHrisEmployeesPositiveResponse,
    ),
  );
}

export function getHrisEmployeesPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisEmployeesPositiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetHrisEmployeesPositiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisEmployeesPositiveResponse' from JSON`,
  );
}
