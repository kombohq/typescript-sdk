/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { catchUnrecognizedEnum, ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const GetHrisEmployeesPositiveResponseGender = {
  Male: "MALE",
  Female: "FEMALE",
  NonBinary: "NON_BINARY",
  NotSpecified: "NOT_SPECIFIED",
} as const;
export type GetHrisEmployeesPositiveResponseGender = OpenEnum<
  typeof GetHrisEmployeesPositiveResponseGender
>;

export const Ethnicity = {
  White: "WHITE",
  Asian: "ASIAN",
  HispanicLatino: "HISPANIC_LATINO",
  Hawaiian: "HAWAIIAN",
  NativeAmerican: "NATIVE_AMERICAN",
  BlackAfricanAmerican: "BLACK_AFRICAN_AMERICAN",
  MultipleEthnicities: "MULTIPLE_ETHNICITIES",
  DeclineToSpecify: "DECLINE_TO_SPECIFY",
} as const;
export type Ethnicity = OpenEnum<typeof Ethnicity>;

export const MaritalStatus = {
  Single: "SINGLE",
  Married: "MARRIED",
  DomesticPartnership: "DOMESTIC_PARTNERSHIP",
  Widowed: "WIDOWED",
  Divorced: "DIVORCED",
  Separated: "SEPARATED",
  NotMarried: "NOT_MARRIED",
} as const;
export type MaritalStatus = OpenEnum<typeof MaritalStatus>;

export const EmploymentStatus = {
  Active: "ACTIVE",
  Pending: "PENDING",
  Inactive: "INACTIVE",
  Leave: "LEAVE",
} as const;
export type EmploymentStatus = OpenEnum<typeof EmploymentStatus>;

export const GetHrisEmployeesPositiveResponseEmploymentType = {
  FullTime: "FULL_TIME",
  PartTime: "PART_TIME",
  Contract: "CONTRACT",
  Internship: "INTERNSHIP",
  Freelance: "FREELANCE",
  WorkingStudent: "WORKING_STUDENT",
  Apprenticeship: "APPRENTICESHIP",
  Training: "TRAINING",
} as const;
export type GetHrisEmployeesPositiveResponseEmploymentType = OpenEnum<
  typeof GetHrisEmployeesPositiveResponseEmploymentType
>;

/**
 * The employee’s home address.
 */
export type HomeAddress = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

/**
 * Enum of the routing type, prefixed with the iso-3166-1-alpha-2 banks origin country. If there is uncertainty about the type, it will be set to null.
 */
export const DomesticBankRoutingType = {
  GbSortCode: "GB_SORT_CODE",
  DeBankleitzahl: "DE_BANKLEITZAHL",
  UsAbaRoutingTransitNumber: "US_ABA_ROUTING_TRANSIT_NUMBER",
  CaRoutingNumber: "CA_ROUTING_NUMBER",
  AuBsbCode: "AU_BSB_CODE",
  FrRib: "FR_RIB",
} as const;
/**
 * Enum of the routing type, prefixed with the iso-3166-1-alpha-2 banks origin country. If there is uncertainty about the type, it will be set to null.
 */
export type DomesticBankRoutingType = ClosedEnum<
  typeof DomesticBankRoutingType
>;

export type DomesticBankRouting = {
  /**
   * Bank routing number (e.g. DE Bankleitzahl, GB Sort Code, US ABA routing number, AU BSB code). This field is not formatted and therefore might contain delimiters (eg. 01-23-45).
   */
  number: string;
  /**
   * Enum of the routing type, prefixed with the iso-3166-1-alpha-2 banks origin country. If there is uncertainty about the type, it will be set to null.
   */
  type: DomesticBankRoutingType | null;
};

export type BankAccount = {
  /**
   * The internationally unique IBAN identifying this account. If we detect a valid IBAN from the account number and this field would otherwise be empty, we will automatically populate this field.
   */
  iban?: string | null | undefined;
  /**
   * The internationally unique BIC/SWIFT code identifying the bank behind this account. If we detect a valid BIC from the domestic bank routing number and this field would otherwise be empty, we will automatically populate this field.
   */
  bic?: string | null | undefined;
  /**
   * The bank-specific account number. Some companies use the account number field to put the IBAN here.
   */
  account_number?: string | null | undefined;
  /**
   * The name of the holder of this account.
   */
  holder_name?: string | null | undefined;
  /**
   * The name of the bank behind this account.
   */
  bank_name?: string | null | undefined;
  domestic_bank_routing?: DomesticBankRouting | null | undefined;
};

export const GetHrisEmployeesPositiveResponsePayPeriod = {
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  TwoWeeks: "TWO_WEEKS",
  HalfMonth: "HALF_MONTH",
  Month: "MONTH",
  TwoMonths: "TWO_MONTHS",
  Quarter: "QUARTER",
  HalfYear: "HALF_YEAR",
  Year: "YEAR",
} as const;
export type GetHrisEmployeesPositiveResponsePayPeriod = OpenEnum<
  typeof GetHrisEmployeesPositiveResponsePayPeriod
>;

export const GetHrisEmployeesPositiveResponsePayFrequency = {
  Daily: "DAILY",
  Weekly: "WEEKLY",
  Biweekly: "BIWEEKLY",
  Monthly: "MONTHLY",
  Semimonthly: "SEMIMONTHLY",
  Quarterly: "QUARTERLY",
  Semiannually: "SEMIANNUALLY",
  Annually: "ANNUALLY",
  ProRata: "PRO_RATA",
} as const;
export type GetHrisEmployeesPositiveResponsePayFrequency = OpenEnum<
  typeof GetHrisEmployeesPositiveResponsePayFrequency
>;

export const EmploymentEmploymentType = {
  FullTime: "FULL_TIME",
  PartTime: "PART_TIME",
  Contract: "CONTRACT",
  Internship: "INTERNSHIP",
  Freelance: "FREELANCE",
  WorkingStudent: "WORKING_STUDENT",
  Apprenticeship: "APPRENTICESHIP",
  Training: "TRAINING",
} as const;
export type EmploymentEmploymentType = OpenEnum<
  typeof EmploymentEmploymentType
>;

export type Employment = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The Kombo ID of the employment’s employee. The ID can be used to retrieve the employee from the `get employees` endpoint.
   */
  employee_id: string;
  /**
   * This field can contain historic job titles. Please use the `job_title` field on the employee for the active job title of an employee.
   */
  job_title: string | null;
  /**
   * The monetary amount paid to an employee.
   */
  pay_rate: number | null;
  /**
   * The time interval which the `pay_rate` is describing.
   *
   * @remarks
   *
   * A `pay_rate` value of `12000` with a `pay_period` of `YEAR` would indicate that the employee receives 12000 over the course of a year. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  pay_period?: GetHrisEmployeesPositiveResponsePayPeriod | null | undefined;
  /**
   * The time interval at which the employee receives payment.
   *
   * @remarks
   *
   * A `pay_rate` of `12000`, with a `pay_period` of `YEAR`, and a `pay_frequency` of `MONTHLY` would indicate that the employee is paid 1000 every month. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  pay_frequency?:
    | GetHrisEmployeesPositiveResponsePayFrequency
    | null
    | undefined;
  /**
   * The employee’s current employment type:
   *
   * @remarks
   *
   * - `FULL_TIME`: the employee is actively employed
   * - `PART_TIME`: the employee is working only part of the usual working hours
   * - `CONTRACT`: the employee is working temporarily under a contract
   * - `INTERNSHIP`: the employee is working as an intern
   * - `FREELANCE`: the employee is working as a freelancer
   * - `WORKING_STUDENT`: the employee is working as a working student
   * - `APPRENTICESHIP`: the employee is working in an apprenticeship
   * - `TRAINING`: the employee is working in a training program
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_type?: EmploymentEmploymentType | null | undefined;
  /**
   * The currency that the employee is paid in. Usually returned in [ISO 4217 currency codes](https://www.iso.org/iso-4217-currency-codes.html).
   */
  pay_currency: string | null;
  /**
   * The date of when the employment started.
   */
  effective_date: Date | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
};

/**
 * The time-unit of the balance.
 */
export const GetHrisEmployeesPositiveResponseBalanceUnit = {
  Hours: "HOURS",
  Days: "DAYS",
} as const;
/**
 * The time-unit of the balance.
 */
export type GetHrisEmployeesPositiveResponseBalanceUnit = ClosedEnum<
  typeof GetHrisEmployeesPositiveResponseBalanceUnit
>;

/**
 * The time-unit of the used time.
 */
export const GetHrisEmployeesPositiveResponseUsedUnit = {
  Hours: "HOURS",
  Days: "DAYS",
} as const;
/**
 * The time-unit of the used time.
 */
export type GetHrisEmployeesPositiveResponseUsedUnit = ClosedEnum<
  typeof GetHrisEmployeesPositiveResponseUsedUnit
>;

export type TimeOffBalance = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The Kombo ID of the employee to which the balance belongs to. The ID can be used to retrieve the employee from the `get employees` endpoint.
   */
  employee_id: string;
  type_id: string;
  /**
   * The amount of time available to the employee.
   */
  balance: number | null;
  /**
   * The time-unit of the balance.
   */
  balance_unit: GetHrisEmployeesPositiveResponseBalanceUnit | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * The amount of time used by the employee.
   */
  used: number | null;
  /**
   * The time-unit of the used time.
   */
  used_unit: GetHrisEmployeesPositiveResponseUsedUnit | null;
};

export const ManagerEmploymentStatus = {
  Active: "ACTIVE",
  Pending: "PENDING",
  Inactive: "INACTIVE",
  Leave: "LEAVE",
} as const;
export type ManagerEmploymentStatus = OpenEnum<typeof ManagerEmploymentStatus>;

export type Manager = {
  /**
   * The employee’s first name.
   */
  first_name: string | null;
  /**
   * The employee’s last name.
   */
  last_name: string | null;
  /**
   * The employee’s full name, including any middle names. Not all HR systems provide an explicit display name, so we recommend falling back to `first_name` and `last_name`.
   */
  display_full_name: string | null;
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The employee’s work email address. If the email address is invalid, we will set this to `null`.
   */
  work_email?: string | null | undefined;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * The employee’s current employment status:
   *
   * @remarks
   *
   * - `ACTIVE`: the employee is **actively employed**
   * - `PENDING`: the employee is **not actively employed yet** (but they signed their contract or are part of an onboarding process)
   * - `INACTIVE`: the employee is **not actively employed** anymore
   * - `LEAVE`: the employee is still employed but **currently on leave** (note that not all HR systems support this status — use our absences API for detailed information)
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_status?: ManagerEmploymentStatus | null | undefined;
  /**
   * The date when the employment ends. Can be in the past or future.
   */
  termination_date: Date | null;
};

/**
 * Type of the group.
 */
export const GroupType = {
  Department: "DEPARTMENT",
  Team: "TEAM",
  CostCenter: "COST_CENTER",
} as const;
/**
 * Type of the group.
 */
export type GroupType = ClosedEnum<typeof GroupType>;

export type Group = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * The name of the group.
   */
  name: string | null;
  /**
   * Type of the group.
   */
  type: GroupType | null;
};

/**
 * The legal entity’s address.
 */
export type LegalEntityAddress = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type LegalEntity = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The legal entity’s name.
   */
  name: string | null;
  /**
   * The legal entity’s address.
   */
  address?: LegalEntityAddress | null | undefined;
};

/**
 * The work location’s address
 */
export type WorkLocationAddress = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type WorkLocation = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The work location’s name
   */
  name: string | null;
  /**
   * The work location’s address
   */
  address?: WorkLocationAddress | null | undefined;
  /**
   * The work location’s type. A freeform string.
   */
  type: string | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
};

export type GetHrisEmployeesPositiveResponseResult = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * The employee’s organization-internal employee number.
   */
  employee_number: string | null;
  /**
   * The employee’s first name.
   */
  first_name: string | null;
  /**
   * The employee’s last name.
   */
  last_name: string | null;
  /**
   * The employee’s nationality.
   */
  nationality: string | null;
  /**
   * The employee’s full name, including any middle names. Not all HR systems provide an explicit display name, so we recommend falling back to `first_name` and `last_name`.
   */
  display_full_name: string | null;
  /**
   * The employee’s job title.
   */
  job_title: string | null;
  /**
   * The employee’s work email address. If the email address is invalid, we will set this to `null`.
   */
  work_email?: string | null | undefined;
  /**
   * The employee’s personal email address. If the email address is invalid, we will set this to `null`.
   */
  personal_email?: string | null | undefined;
  /**
   * The employee’s mobile phone number.
   */
  mobile_phone_number: string | null;
  /**
   * The employee’s social security number
   */
  ssn: string | null;
  /**
   * The employee’s tax ID.
   */
  tax_id: string | null;
  /**
   * The employee’s gender.
   */
  gender?: GetHrisEmployeesPositiveResponseGender | null | undefined;
  /**
   * The employee’s ethnicity. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  ethnicity?: Ethnicity | null | undefined;
  /**
   * The employee’s current marital status. In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  marital_status?: MaritalStatus | null | undefined;
  /**
   * The employee’s current employment status:
   *
   * @remarks
   *
   * - `ACTIVE`: the employee is **actively employed**
   * - `PENDING`: the employee is **not actively employed yet** (but they signed their contract or are part of an onboarding process)
   * - `INACTIVE`: the employee is **not actively employed** anymore
   * - `LEAVE`: the employee is still employed but **currently on leave** (note that not all HR systems support this status — use our absences API for detailed information)
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_status?: EmploymentStatus | null | undefined;
  /**
   * The employee’s current employment type:
   *
   * @remarks
   *
   * - `FULL_TIME`: the employee is actively employed
   * - `PART_TIME`: the employee is working only part of the usual working hours
   * - `CONTRACT`: the employee is working temporarily under a contract
   * - `INTERNSHIP`: the employee is working as an intern
   * - `FREELANCE`: the employee is working as a freelancer
   * - `WORKING_STUDENT`: the employee is working as a working student
   * - `APPRENTICESHIP`: the employee is working in an apprenticeship
   * - `TRAINING`: the employee is working in a training program
   *
   *  In rare cases where we can’t find a clear mapping, the original string is passed through.
   */
  employment_type?:
    | GetHrisEmployeesPositiveResponseEmploymentType
    | null
    | undefined;
  /**
   * The employee’s weekly working hours.
   */
  weekly_hours: number | null;
  /**
   * URL to the employee’s avatar. This is either the raw URL from the HR system (in cases where it can be requested without short-lived authentication) _or_ a URL to a temporarily cached version of the file hosted by Kombo. Kombo will delete the cached file after its deletion in the source system.
   */
  avatar: string | null;
  /**
   * The Kombo ID of the employee’s work location. The ID can be used to retrieve the work location from the `get work locations` endpoint.
   */
  work_location_id: string | null;
  /**
   * The Kombo ID of the employee’s legal entity. The ID can be used to retrieve the legal entity from the `get legal entities` endpoint.
   */
  legal_entity_id: string | null;
  /**
   * The Kombo ID of the employee’s manager. The ID can be used to retrieve the manager from the `get employees` endpoint.
   */
  manager_id: string | null;
  /**
   * The employee’s home address.
   */
  home_address?: HomeAddress | null | undefined;
  /**
   * The employee’s bank accounts.
   */
  bank_accounts?: Array<BankAccount> | null | undefined;
  /**
   * The employee’s date of birth.
   */
  date_of_birth: Date | null;
  /**
   * The date the employee started working for the organization.
   */
  start_date: Date | null;
  /**
   * The date when the employment ends. Can be in the past or future.
   */
  termination_date: Date | null;
  /**
   * The date and time the object was created in the remote system.
   */
  remote_created_at: Date | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  /**
   * A key-value store of fields not covered by the schema. [Read more](/custom-fields)
   */
  custom_fields: { [k: string]: any } | null;
  employments: Array<Employment>;
  time_off_balances: Array<TimeOffBalance>;
  manager: Manager | null;
  groups: Array<Group>;
  legal_entity: LegalEntity | null;
  work_location: WorkLocation | null;
};

export type GetHrisEmployeesPositiveResponseData = {
  /**
   * Cursor string that can be passed to the `cursor` query parameter to get the next page. If this is `null`, then there are no more pages.
   */
  next: string | null;
  results: Array<GetHrisEmployeesPositiveResponseResult>;
};

export type GetHrisEmployeesPositiveResponse = {
  status: "success";
  data: GetHrisEmployeesPositiveResponseData;
};

/** @internal */
export const GetHrisEmployeesPositiveResponseGender$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseGender,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetHrisEmployeesPositiveResponseGender),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Ethnicity$inboundSchema: z.ZodType<
  Ethnicity,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Ethnicity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MaritalStatus$inboundSchema: z.ZodType<
  MaritalStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MaritalStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EmploymentStatus$inboundSchema: z.ZodType<
  EmploymentStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EmploymentStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetHrisEmployeesPositiveResponseEmploymentType$inboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponseEmploymentType,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(GetHrisEmployeesPositiveResponseEmploymentType),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const HomeAddress$inboundSchema: z.ZodType<
  HomeAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

export function homeAddressFromJSON(
  jsonString: string,
): SafeParseResult<HomeAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HomeAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HomeAddress' from JSON`,
  );
}

/** @internal */
export const DomesticBankRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof DomesticBankRoutingType
> = z.nativeEnum(DomesticBankRoutingType);

/** @internal */
export const DomesticBankRouting$inboundSchema: z.ZodType<
  DomesticBankRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  number: z.string(),
  type: z.nullable(DomesticBankRoutingType$inboundSchema),
});

export function domesticBankRoutingFromJSON(
  jsonString: string,
): SafeParseResult<DomesticBankRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DomesticBankRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DomesticBankRouting' from JSON`,
  );
}

/** @internal */
export const BankAccount$inboundSchema: z.ZodType<
  BankAccount,
  z.ZodTypeDef,
  unknown
> = z.object({
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  account_number: z.nullable(z.string()).optional(),
  holder_name: z.nullable(z.string()).optional(),
  bank_name: z.nullable(z.string()).optional(),
  domestic_bank_routing: z.nullable(
    z.lazy(() => DomesticBankRouting$inboundSchema),
  ).optional(),
});

export function bankAccountFromJSON(
  jsonString: string,
): SafeParseResult<BankAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BankAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BankAccount' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponsePayPeriod$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponsePayPeriod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetHrisEmployeesPositiveResponsePayPeriod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetHrisEmployeesPositiveResponsePayFrequency$inboundSchema:
  z.ZodType<
    GetHrisEmployeesPositiveResponsePayFrequency,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(GetHrisEmployeesPositiveResponsePayFrequency),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const EmploymentEmploymentType$inboundSchema: z.ZodType<
  EmploymentEmploymentType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EmploymentEmploymentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Employment$inboundSchema: z.ZodType<
  Employment,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  job_title: z.nullable(z.string()),
  pay_rate: z.nullable(z.number()),
  pay_period: z.nullable(
    GetHrisEmployeesPositiveResponsePayPeriod$inboundSchema,
  ).optional(),
  pay_frequency: z.nullable(
    GetHrisEmployeesPositiveResponsePayFrequency$inboundSchema,
  ).optional(),
  employment_type: z.nullable(EmploymentEmploymentType$inboundSchema)
    .optional(),
  pay_currency: z.nullable(z.string()),
  effective_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  custom_fields: z.nullable(z.record(z.any())),
});

export function employmentFromJSON(
  jsonString: string,
): SafeParseResult<Employment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Employment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Employment' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema:
  z.ZodNativeEnum<typeof GetHrisEmployeesPositiveResponseBalanceUnit> = z
    .nativeEnum(GetHrisEmployeesPositiveResponseBalanceUnit);

/** @internal */
export const GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema:
  z.ZodNativeEnum<typeof GetHrisEmployeesPositiveResponseUsedUnit> = z
    .nativeEnum(GetHrisEmployeesPositiveResponseUsedUnit);

/** @internal */
export const TimeOffBalance$inboundSchema: z.ZodType<
  TimeOffBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  employee_id: z.string(),
  type_id: z.string(),
  balance: z.nullable(z.number()),
  balance_unit: z.nullable(
    GetHrisEmployeesPositiveResponseBalanceUnit$inboundSchema,
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  used: z.nullable(z.number()),
  used_unit: z.nullable(GetHrisEmployeesPositiveResponseUsedUnit$inboundSchema),
});

export function timeOffBalanceFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalance' from JSON`,
  );
}

/** @internal */
export const ManagerEmploymentStatus$inboundSchema: z.ZodType<
  ManagerEmploymentStatus,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ManagerEmploymentStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Manager$inboundSchema: z.ZodType<Manager, z.ZodTypeDef, unknown> =
  z.object({
    first_name: z.nullable(z.string()),
    last_name: z.nullable(z.string()),
    display_full_name: z.nullable(z.string()),
    id: z.string(),
    work_email: z.nullable(z.string()).optional(),
    remote_id: z.string(),
    employment_status: z.nullable(ManagerEmploymentStatus$inboundSchema)
      .optional(),
    termination_date: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ),
  });

export function managerFromJSON(
  jsonString: string,
): SafeParseResult<Manager, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Manager$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Manager' from JSON`,
  );
}

/** @internal */
export const GroupType$inboundSchema: z.ZodNativeEnum<typeof GroupType> = z
  .nativeEnum(GroupType);

/** @internal */
export const Group$inboundSchema: z.ZodType<Group, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    remote_id: z.string(),
    name: z.nullable(z.string()),
    type: z.nullable(GroupType$inboundSchema),
  });

export function groupFromJSON(
  jsonString: string,
): SafeParseResult<Group, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Group$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Group' from JSON`,
  );
}

/** @internal */
export const LegalEntityAddress$inboundSchema: z.ZodType<
  LegalEntityAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

export function legalEntityAddressFromJSON(
  jsonString: string,
): SafeParseResult<LegalEntityAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LegalEntityAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LegalEntityAddress' from JSON`,
  );
}

/** @internal */
export const LegalEntity$inboundSchema: z.ZodType<
  LegalEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  address: z.nullable(z.lazy(() => LegalEntityAddress$inboundSchema))
    .optional(),
});

export function legalEntityFromJSON(
  jsonString: string,
): SafeParseResult<LegalEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LegalEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LegalEntity' from JSON`,
  );
}

/** @internal */
export const WorkLocationAddress$inboundSchema: z.ZodType<
  WorkLocationAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

export function workLocationAddressFromJSON(
  jsonString: string,
): SafeParseResult<WorkLocationAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkLocationAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkLocationAddress' from JSON`,
  );
}

/** @internal */
export const WorkLocation$inboundSchema: z.ZodType<
  WorkLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  name: z.nullable(z.string()),
  address: z.nullable(z.lazy(() => WorkLocationAddress$inboundSchema))
    .optional(),
  type: z.nullable(z.string()),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
});

export function workLocationFromJSON(
  jsonString: string,
): SafeParseResult<WorkLocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkLocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkLocation' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponseResult$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  employee_number: z.nullable(z.string()),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  nationality: z.nullable(z.string()),
  display_full_name: z.nullable(z.string()),
  job_title: z.nullable(z.string()),
  work_email: z.nullable(z.string()).optional(),
  personal_email: z.nullable(z.string()).optional(),
  mobile_phone_number: z.nullable(z.string()),
  ssn: z.nullable(z.string()),
  tax_id: z.nullable(z.string()),
  gender: z.nullable(GetHrisEmployeesPositiveResponseGender$inboundSchema)
    .optional(),
  ethnicity: z.nullable(Ethnicity$inboundSchema).optional(),
  marital_status: z.nullable(MaritalStatus$inboundSchema).optional(),
  employment_status: z.nullable(EmploymentStatus$inboundSchema).optional(),
  employment_type: z.nullable(
    GetHrisEmployeesPositiveResponseEmploymentType$inboundSchema,
  ).optional(),
  weekly_hours: z.nullable(z.number()),
  avatar: z.nullable(z.string()),
  work_location_id: z.nullable(z.string()),
  legal_entity_id: z.nullable(z.string()),
  manager_id: z.nullable(z.string()),
  home_address: z.nullable(z.lazy(() => HomeAddress$inboundSchema)).optional(),
  bank_accounts: z.nullable(z.array(z.lazy(() => BankAccount$inboundSchema)))
    .optional(),
  date_of_birth: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  start_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  termination_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  custom_fields: z.nullable(z.record(z.any())),
  employments: z.array(z.lazy(() => Employment$inboundSchema)),
  time_off_balances: z.array(z.lazy(() => TimeOffBalance$inboundSchema)),
  manager: z.nullable(z.lazy(() => Manager$inboundSchema)),
  groups: z.array(z.lazy(() => Group$inboundSchema)),
  legal_entity: z.nullable(z.lazy(() => LegalEntity$inboundSchema)),
  work_location: z.nullable(z.lazy(() => WorkLocation$inboundSchema)),
});

export function getHrisEmployeesPositiveResponseResultFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisEmployeesPositiveResponseResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetHrisEmployeesPositiveResponseResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisEmployeesPositiveResponseResult' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponseData$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetHrisEmployeesPositiveResponseResult$inboundSchema),
  ),
});

export function getHrisEmployeesPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisEmployeesPositiveResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetHrisEmployeesPositiveResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisEmployeesPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetHrisEmployeesPositiveResponse$inboundSchema: z.ZodType<
  GetHrisEmployeesPositiveResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetHrisEmployeesPositiveResponseData$inboundSchema),
});

export function getHrisEmployeesPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetHrisEmployeesPositiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetHrisEmployeesPositiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetHrisEmployeesPositiveResponse' from JSON`,
  );
}
