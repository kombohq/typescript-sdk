/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type GetIntegrationsIntegrationIdPositiveResponseTool = {
  /**
   * The ID of the connected tool in Kombo (e.g. `factorial`).
   */
  id: string;
  label: string;
  /**
   * Internal label that can help you debug specific variants of the integration. Only show the `label` to your users.
   */
  internal_label: string | null;
  /**
   * URL to an SVG logo of the connected tool. The logo usually contains the tool name.
   */
  logo_url: string;
  /**
   * URL to a square SVG icon of the connected tool.
   */
  icon_url: string;
};

export const GetIntegrationsIntegrationIdPositiveResponseCategory = {
  Hris: "HRIS",
  Ats: "ATS",
  Assessment: "ASSESSMENT",
  Lms: "LMS",
} as const;
export type GetIntegrationsIntegrationIdPositiveResponseCategory = ClosedEnum<
  typeof GetIntegrationsIntegrationIdPositiveResponseCategory
>;

/**
 * The current status of the integration.
 *
 * @remarks
 *
 * - `ACTIVE`: The integration is syncing data as expected.
 * - `INVALID`: The integration has stopped syncing data because of invalid credentials. To fix this, reach out to your customer to [reconnect the integration](../guides/integration-states#credentials-invalid).
 * - `INACTIVE`: The integration has stopped syncing as it's been manually set to inactive. You can [enable it again](../guides/integration-states#inactive) in the integration's page.
 */
export const GetIntegrationsIntegrationIdPositiveResponseStatus = {
  Active: "ACTIVE",
  Invalid: "INVALID",
  Inactive: "INACTIVE",
} as const;
/**
 * The current status of the integration.
 *
 * @remarks
 *
 * - `ACTIVE`: The integration is syncing data as expected.
 * - `INVALID`: The integration has stopped syncing data because of invalid credentials. To fix this, reach out to your customer to [reconnect the integration](../guides/integration-states#credentials-invalid).
 * - `INACTIVE`: The integration has stopped syncing as it's been manually set to inactive. You can [enable it again](../guides/integration-states#inactive) in the integration's page.
 */
export type GetIntegrationsIntegrationIdPositiveResponseStatus = ClosedEnum<
  typeof GetIntegrationsIntegrationIdPositiveResponseStatus
>;

/**
 * The setup_status is used in conjunction with the filtering and field mapping features. If these are enabled in the connection flow, the integration will start in an "INCOMPLETE" state and move to "COMPLETE" once all steps are finished.
 *
 * @remarks
 *
 * - `INCOMPLETE`: Setup is still in progress. Some steps aren’t finished, so no data is available yet. Syncs only run as needed for setup.
 * - `FINAL_SYNC_PENDING`: Setup is complete, and the final sync is running. Data will be available after this sync is done.
 * - `COMPLETED`: Setup is fully finished, and the integration is ready to use.
 */
export const GetIntegrationsIntegrationIdPositiveResponseSetupStatus = {
  Incomplete: "INCOMPLETE",
  FinalSyncPending: "FINAL_SYNC_PENDING",
  Completed: "COMPLETED",
} as const;
/**
 * The setup_status is used in conjunction with the filtering and field mapping features. If these are enabled in the connection flow, the integration will start in an "INCOMPLETE" state and move to "COMPLETE" once all steps are finished.
 *
 * @remarks
 *
 * - `INCOMPLETE`: Setup is still in progress. Some steps aren’t finished, so no data is available yet. Syncs only run as needed for setup.
 * - `FINAL_SYNC_PENDING`: Setup is complete, and the final sync is running. Data will be available after this sync is done.
 * - `COMPLETED`: Setup is fully finished, and the integration is ready to use.
 */
export type GetIntegrationsIntegrationIdPositiveResponseSetupStatus =
  ClosedEnum<typeof GetIntegrationsIntegrationIdPositiveResponseSetupStatus>;

export type GetIntegrationsIntegrationIdPositiveResponseEndUser = {
  organization_name: string;
  creator_email: string | null;
  /**
   * The ID you have passed initially to the connection flow to create this integration.
   */
  origin_id: string | null;
};

export type ScopeConfig = {
  id: string;
  name: string | null;
};

/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export const GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus =
  {
    Supported: "SUPPORTED",
    Unsupported: "UNSUPPORTED",
    NotImplemented: "NOT_IMPLEMENTED",
    Unknown: "UNKNOWN",
  } as const;
/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export type GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus =
  ClosedEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus
  >;

/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export const ReadModelScopeConfigSetting = {
  Enabled: "ENABLED",
  Disabled: "DISABLED",
  Optional: "OPTIONAL",
} as const;
/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export type ReadModelScopeConfigSetting = ClosedEnum<
  typeof ReadModelScopeConfigSetting
>;

/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export const GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus =
  {
    Supported: "SUPPORTED",
    Unsupported: "UNSUPPORTED",
    NotImplemented: "NOT_IMPLEMENTED",
    Unknown: "UNKNOWN",
  } as const;
/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export type GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus =
  ClosedEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus
  >;

/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export const FieldScopeConfigSetting = {
  Enabled: "ENABLED",
  Disabled: "DISABLED",
  Optional: "OPTIONAL",
} as const;
/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export type FieldScopeConfigSetting = ClosedEnum<
  typeof FieldScopeConfigSetting
>;

export type GetIntegrationsIntegrationIdPositiveResponseReadModelField = {
  /**
   * Key of the field in the API (e.g. first_name).
   */
  id: string;
  /**
   * Whether the datapoint is available and enabled and not opted out of.
   */
  is_available: boolean;
  /**
   * The status of a datapoint of an integrated tool:
   *
   * @remarks
   *
   * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
   * - `UNSUPPORTED`: the tool does not support the datapoint.
   * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
   * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
   */
  coverage_status:
    GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus;
  /**
   * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
   */
  scope_config_setting: FieldScopeConfigSetting;
  /**
   * Whether the datapoint is opted out by your customer in the connection flow.
   */
  opted_out_by_customer: boolean;
};

export type GetIntegrationsIntegrationIdPositiveResponseReadModel = {
  /**
   * ID of the model (e.g. hris_employees).
   */
  id: string;
  /**
   * Label of the model (e.g. Employees).
   */
  label: string;
  /**
   * Whether the datapoint is available and enabled and not opted out of.
   */
  is_available: boolean;
  /**
   * The status of a datapoint of an integrated tool:
   *
   * @remarks
   *
   * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
   * - `UNSUPPORTED`: the tool does not support the datapoint.
   * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
   * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
   */
  coverage_status:
    GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus;
  /**
   * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
   */
  scope_config_setting: ReadModelScopeConfigSetting;
  /**
   * Whether the datapoint is opted out by your customer in the connection flow.
   */
  opted_out_by_customer: boolean;
  fields: Array<GetIntegrationsIntegrationIdPositiveResponseReadModelField>;
};

/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export const GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus =
  {
    Supported: "SUPPORTED",
    Unsupported: "UNSUPPORTED",
    NotImplemented: "NOT_IMPLEMENTED",
    Unknown: "UNKNOWN",
  } as const;
/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export type GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus =
  ClosedEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus
  >;

/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export const WriteActionScopeConfigSetting = {
  Enabled: "ENABLED",
  Disabled: "DISABLED",
  Optional: "OPTIONAL",
} as const;
/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export type WriteActionScopeConfigSetting = ClosedEnum<
  typeof WriteActionScopeConfigSetting
>;

/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export const GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus =
  {
    Supported: "SUPPORTED",
    Unsupported: "UNSUPPORTED",
    NotImplemented: "NOT_IMPLEMENTED",
    Unknown: "UNKNOWN",
  } as const;
/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export type GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus =
  ClosedEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus
  >;

export type GetIntegrationsIntegrationIdPositiveResponseWriteActionField = {
  /**
   * Key of the input field (e.g. candidate.first_name).
   */
  id: string;
  /**
   * Whether the datapoint is available and enabled and not opted out of.
   */
  is_available: boolean;
  /**
   * The status of a datapoint of an integrated tool:
   *
   * @remarks
   *
   * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
   * - `UNSUPPORTED`: the tool does not support the datapoint.
   * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
   * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
   */
  coverage_status:
    GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus;
};

export type GetIntegrationsIntegrationIdPositiveResponseWriteAction = {
  /**
   * ID of the action (e.g. ats_create_candidate).
   */
  id: string;
  /**
   * Label of the action (e.g. Create candidate).
   */
  label: string;
  /**
   * Whether the datapoint is available and enabled and not opted out of.
   */
  is_available: boolean;
  /**
   * The status of a datapoint of an integrated tool:
   *
   * @remarks
   *
   * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
   * - `UNSUPPORTED`: the tool does not support the datapoint.
   * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
   * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
   */
  coverage_status:
    GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus;
  /**
   * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
   */
  scope_config_setting: WriteActionScopeConfigSetting;
  /**
   * Whether the datapoint is opted out by your customer in the connection flow.
   */
  opted_out_by_customer: boolean;
  /**
   * Field support status for the action. Please note that action fields can't be configured in the scope config or opted out by your customer.
   */
  fields: Array<GetIntegrationsIntegrationIdPositiveResponseWriteActionField>;
};

export type GetIntegrationsIntegrationIdPositiveResponseData = {
  id: string;
  tool: GetIntegrationsIntegrationIdPositiveResponseTool;
  category: GetIntegrationsIntegrationIdPositiveResponseCategory;
  /**
   * The current status of the integration.
   *
   * @remarks
   *
   * - `ACTIVE`: The integration is syncing data as expected.
   * - `INVALID`: The integration has stopped syncing data because of invalid credentials. To fix this, reach out to your customer to [reconnect the integration](../guides/integration-states#credentials-invalid).
   * - `INACTIVE`: The integration has stopped syncing as it's been manually set to inactive. You can [enable it again](../guides/integration-states#inactive) in the integration's page.
   */
  status: GetIntegrationsIntegrationIdPositiveResponseStatus;
  /**
   * The setup_status is used in conjunction with the filtering and field mapping features. If these are enabled in the connection flow, the integration will start in an "INCOMPLETE" state and move to "COMPLETE" once all steps are finished.
   *
   * @remarks
   *
   * - `INCOMPLETE`: Setup is still in progress. Some steps aren’t finished, so no data is available yet. Syncs only run as needed for setup.
   * - `FINAL_SYNC_PENDING`: Setup is complete, and the final sync is running. Data will be available after this sync is done.
   * - `COMPLETED`: Setup is fully finished, and the integration is ready to use.
   */
  setup_status: GetIntegrationsIntegrationIdPositiveResponseSetupStatus;
  end_user: GetIntegrationsIntegrationIdPositiveResponseEndUser;
  scope_config: ScopeConfig;
  /**
   * The date when the integration configuration (e.g. filters, scope config) was changed, invalidating the synced data. It is cleared after a successful sync. If this field is `null` the data you fetch is valid to the state of the last sync or webhook event received. Otherwise it will be set to `null` with the next successful sync.
   */
  data_expired_at: Date | null;
  /**
   * YYYY-MM-DDTHH:mm:ss.sssZ
   */
  created_at: Date;
  beta: boolean;
  read_models: Array<GetIntegrationsIntegrationIdPositiveResponseReadModel>;
  write_actions: Array<GetIntegrationsIntegrationIdPositiveResponseWriteAction>;
};

export type GetIntegrationsIntegrationIdPositiveResponse = {
  status: "success";
  data: GetIntegrationsIntegrationIdPositiveResponseData;
};

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseTool$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    label: z.string(),
    internal_label: z.nullable(z.string()),
    logo_url: z.string(),
    icon_url: z.string(),
  });

export function getIntegrationsIntegrationIdPositiveResponseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseTool' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseCategory$inboundSchema:
  z.ZodNativeEnum<typeof GetIntegrationsIntegrationIdPositiveResponseCategory> =
    z.nativeEnum(GetIntegrationsIntegrationIdPositiveResponseCategory);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof GetIntegrationsIntegrationIdPositiveResponseStatus> = z
    .nativeEnum(GetIntegrationsIntegrationIdPositiveResponseStatus);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseSetupStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseSetupStatus
  > = z.nativeEnum(GetIntegrationsIntegrationIdPositiveResponseSetupStatus);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseEndUser$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseEndUser,
    z.ZodTypeDef,
    unknown
  > = z.object({
    organization_name: z.string(),
    creator_email: z.nullable(z.string()),
    origin_id: z.nullable(z.string()),
  });

export function getIntegrationsIntegrationIdPositiveResponseEndUserFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseEndUser,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseEndUser$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseEndUser' from JSON`,
  );
}

/** @internal */
export const ScopeConfig$inboundSchema: z.ZodType<
  ScopeConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.nullable(z.string()),
});

export function scopeConfigFromJSON(
  jsonString: string,
): SafeParseResult<ScopeConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScopeConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScopeConfig' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus
  > = z.nativeEnum(
    GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus,
  );

/** @internal */
export const ReadModelScopeConfigSetting$inboundSchema: z.ZodNativeEnum<
  typeof ReadModelScopeConfigSetting
> = z.nativeEnum(ReadModelScopeConfigSetting);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus
  > = z.nativeEnum(
    GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus,
  );

/** @internal */
export const FieldScopeConfigSetting$inboundSchema: z.ZodNativeEnum<
  typeof FieldScopeConfigSetting
> = z.nativeEnum(FieldScopeConfigSetting);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseReadModelField$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseReadModelField,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    is_available: z.boolean(),
    coverage_status:
      GetIntegrationsIntegrationIdPositiveResponseReadModelFieldCoverageStatus$inboundSchema,
    scope_config_setting: FieldScopeConfigSetting$inboundSchema,
    opted_out_by_customer: z.boolean(),
  });

export function getIntegrationsIntegrationIdPositiveResponseReadModelFieldFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseReadModelField,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseReadModelField$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseReadModelField' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseReadModel$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseReadModel,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    label: z.string(),
    is_available: z.boolean(),
    coverage_status:
      GetIntegrationsIntegrationIdPositiveResponseReadModelCoverageStatus$inboundSchema,
    scope_config_setting: ReadModelScopeConfigSetting$inboundSchema,
    opted_out_by_customer: z.boolean(),
    fields: z.array(
      z.lazy(() =>
        GetIntegrationsIntegrationIdPositiveResponseReadModelField$inboundSchema
      ),
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseReadModelFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseReadModel,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseReadModel$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseReadModel' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus
  > = z.nativeEnum(
    GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus,
  );

/** @internal */
export const WriteActionScopeConfigSetting$inboundSchema: z.ZodNativeEnum<
  typeof WriteActionScopeConfigSetting
> = z.nativeEnum(WriteActionScopeConfigSetting);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus
  > = z.nativeEnum(
    GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus,
  );

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseWriteActionField$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseWriteActionField,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    is_available: z.boolean(),
    coverage_status:
      GetIntegrationsIntegrationIdPositiveResponseWriteActionFieldCoverageStatus$inboundSchema,
  });

export function getIntegrationsIntegrationIdPositiveResponseWriteActionFieldFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseWriteActionField,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseWriteActionField$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseWriteActionField' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseWriteAction$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseWriteAction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    label: z.string(),
    is_available: z.boolean(),
    coverage_status:
      GetIntegrationsIntegrationIdPositiveResponseWriteActionCoverageStatus$inboundSchema,
    scope_config_setting: WriteActionScopeConfigSetting$inboundSchema,
    opted_out_by_customer: z.boolean(),
    fields: z.array(
      z.lazy(() =>
        GetIntegrationsIntegrationIdPositiveResponseWriteActionField$inboundSchema
      ),
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseWriteActionFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseWriteAction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseWriteAction$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseWriteAction' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseData$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    tool: z.lazy(() =>
      GetIntegrationsIntegrationIdPositiveResponseTool$inboundSchema
    ),
    category:
      GetIntegrationsIntegrationIdPositiveResponseCategory$inboundSchema,
    status: GetIntegrationsIntegrationIdPositiveResponseStatus$inboundSchema,
    setup_status:
      GetIntegrationsIntegrationIdPositiveResponseSetupStatus$inboundSchema,
    end_user: z.lazy(() =>
      GetIntegrationsIntegrationIdPositiveResponseEndUser$inboundSchema
    ),
    scope_config: z.lazy(() => ScopeConfig$inboundSchema),
    data_expired_at: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ),
    created_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    beta: z.boolean(),
    read_models: z.array(
      z.lazy(() =>
        GetIntegrationsIntegrationIdPositiveResponseReadModel$inboundSchema
      ),
    ),
    write_actions: z.array(
      z.lazy(() =>
        GetIntegrationsIntegrationIdPositiveResponseWriteAction$inboundSchema
      ),
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseData$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponse$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    status: z.literal("success"),
    data: z.lazy(() =>
      GetIntegrationsIntegrationIdPositiveResponseData$inboundSchema
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponse' from JSON`,
  );
}
