/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type GetIntegrationsIntegrationIdPositiveResponseTool = {
  /**
   * The ID of the connected tool in Kombo (e.g. `factorial`).
   */
  id: string;
  label: string;
  /**
   * Internal label that can help you debug specific variants of the integration. Only show the `label` to your users.
   */
  internal_label: string | null;
  /**
   * URL to an SVG logo of the connected tool. The logo usually contains the tool name.
   */
  logo_url: string;
  /**
   * URL to a square SVG icon of the connected tool.
   */
  icon_url: string;
};

export const GetIntegrationsIntegrationIdPositiveResponseCategory = {
  Hris: "HRIS",
  Ats: "ATS",
  Assessment: "ASSESSMENT",
} as const;
export type GetIntegrationsIntegrationIdPositiveResponseCategory = ClosedEnum<
  typeof GetIntegrationsIntegrationIdPositiveResponseCategory
>;

/**
 * The current status of the integration.
 *
 * @remarks
 *
 * - `ACTIVE`: The integration is syncing data as expected.
 * - `INVALID`: The integration has stopped syncing data because of invalid credentials. To fix this, reach out to your customer to [reconnect the integration](../guides/integration-states#credentials-invalid).
 * - `INACTIVE`: The integration has stopped syncing as it's been manually set to inactive. You can [enable it again](../guides/integration-states#inactive) in the integration's page.
 */
export const GetIntegrationsIntegrationIdPositiveResponseStatus = {
  Active: "ACTIVE",
  Invalid: "INVALID",
  Inactive: "INACTIVE",
} as const;
/**
 * The current status of the integration.
 *
 * @remarks
 *
 * - `ACTIVE`: The integration is syncing data as expected.
 * - `INVALID`: The integration has stopped syncing data because of invalid credentials. To fix this, reach out to your customer to [reconnect the integration](../guides/integration-states#credentials-invalid).
 * - `INACTIVE`: The integration has stopped syncing as it's been manually set to inactive. You can [enable it again](../guides/integration-states#inactive) in the integration's page.
 */
export type GetIntegrationsIntegrationIdPositiveResponseStatus = ClosedEnum<
  typeof GetIntegrationsIntegrationIdPositiveResponseStatus
>;

/**
 * The setup_status is used in conjunction with the filtering and field mapping features. If these are enabled in the connection flow, the integration will start in an "INCOMPLETE" state and move to "COMPLETE" once all steps are finished.
 *
 * @remarks
 *
 * - `INCOMPLETE`: Setup is still in progress. Some steps aren’t finished, so no data is available yet. Syncs only run as needed for setup.
 * - `FINAL_SYNC_PENDING`: Setup is complete, and the final sync is running. Data will be available after this sync is done.
 * - `COMPLETED`: Setup is fully finished, and the integration is ready to use.
 */
export const GetIntegrationsIntegrationIdPositiveResponseSetupStatus = {
  Incomplete: "INCOMPLETE",
  FinalSyncPending: "FINAL_SYNC_PENDING",
  Completed: "COMPLETED",
} as const;
/**
 * The setup_status is used in conjunction with the filtering and field mapping features. If these are enabled in the connection flow, the integration will start in an "INCOMPLETE" state and move to "COMPLETE" once all steps are finished.
 *
 * @remarks
 *
 * - `INCOMPLETE`: Setup is still in progress. Some steps aren’t finished, so no data is available yet. Syncs only run as needed for setup.
 * - `FINAL_SYNC_PENDING`: Setup is complete, and the final sync is running. Data will be available after this sync is done.
 * - `COMPLETED`: Setup is fully finished, and the integration is ready to use.
 */
export type GetIntegrationsIntegrationIdPositiveResponseSetupStatus =
  ClosedEnum<typeof GetIntegrationsIntegrationIdPositiveResponseSetupStatus>;

export type GetIntegrationsIntegrationIdPositiveResponseEndUser = {
  organization_name: string;
  creator_email: string | null;
  /**
   * The ID you have passed initially to the connection flow to create this integration.
   */
  origin_id: string | null;
};

export type ScopeConfig = {
  id: string;
  name: string | null;
};

/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export const GetIntegrationsIntegrationIdPositiveResponseCoverageStatus = {
  Supported: "SUPPORTED",
  Unsupported: "UNSUPPORTED",
  NotImplemented: "NOT_IMPLEMENTED",
  Unknown: "UNKNOWN",
} as const;
/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export type GetIntegrationsIntegrationIdPositiveResponseCoverageStatus =
  ClosedEnum<typeof GetIntegrationsIntegrationIdPositiveResponseCoverageStatus>;

/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export const ScopeConfigSetting = {
  Enabled: "ENABLED",
  Disabled: "DISABLED",
  Optional: "OPTIONAL",
} as const;
/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export type ScopeConfigSetting = ClosedEnum<typeof ScopeConfigSetting>;

/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export const GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus = {
  Supported: "SUPPORTED",
  Unsupported: "UNSUPPORTED",
  NotImplemented: "NOT_IMPLEMENTED",
  Unknown: "UNKNOWN",
} as const;
/**
 * The status of a datapoint of an integrated tool:
 *
 * @remarks
 *
 * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
 * - `UNSUPPORTED`: the tool does not support the datapoint.
 * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
 * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
 */
export type GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus =
  ClosedEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus
  >;

/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export const FieldScopeConfigSetting = {
  Enabled: "ENABLED",
  Disabled: "DISABLED",
  Optional: "OPTIONAL",
} as const;
/**
 * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
 */
export type FieldScopeConfigSetting = ClosedEnum<
  typeof FieldScopeConfigSetting
>;

export type GetIntegrationsIntegrationIdPositiveResponseField = {
  /**
   * Key of the field in the API (e.g. first_name).
   */
  id: string;
  /**
   * Whether the datapoint is available and enabled and not opted out of.
   */
  is_available: boolean;
  /**
   * The status of a datapoint of an integrated tool:
   *
   * @remarks
   *
   * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
   * - `UNSUPPORTED`: the tool does not support the datapoint.
   * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
   * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
   */
  coverage_status:
    GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus;
  /**
   * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
   */
  scope_config_setting: FieldScopeConfigSetting;
  /**
   * Whether the datapoint is opted out by your customer in the connection flow.
   */
  opted_out_by_customer: boolean;
};

export type GetIntegrationsIntegrationIdPositiveResponseReadModel = {
  /**
   * ID of the model (e.g. hris_employees).
   */
  id: string;
  /**
   * Label of the model (e.g. Employees).
   */
  label: string;
  /**
   * Whether the datapoint is available and enabled and not opted out of.
   */
  is_available: boolean;
  /**
   * The status of a datapoint of an integrated tool:
   *
   * @remarks
   *
   * - `SUPPORTED`: the tool supports the datapoint and it can be used through Kombo.
   * - `UNSUPPORTED`: the tool does not support the datapoint.
   * - `NOT_IMPLEMENTED`: tool supports the datapoint but it was not integrated by Kombo for a given reason (see coverage grid).
   * - `UNKNOWN`: the datapoint is not integrated yet and Kombo has no information about it's availability in the tool.
   */
  coverage_status: GetIntegrationsIntegrationIdPositiveResponseCoverageStatus;
  /**
   * The setting of the datapoint in the scope config that you configured in the Kombo dashboard.
   */
  scope_config_setting: ScopeConfigSetting;
  /**
   * Whether the datapoint is opted out by your customer in the connection flow.
   */
  opted_out_by_customer: boolean;
  fields: Array<GetIntegrationsIntegrationIdPositiveResponseField>;
};

export type GetIntegrationsIntegrationIdPositiveResponseData = {
  id: string;
  tool: GetIntegrationsIntegrationIdPositiveResponseTool;
  category: GetIntegrationsIntegrationIdPositiveResponseCategory;
  /**
   * The current status of the integration.
   *
   * @remarks
   *
   * - `ACTIVE`: The integration is syncing data as expected.
   * - `INVALID`: The integration has stopped syncing data because of invalid credentials. To fix this, reach out to your customer to [reconnect the integration](../guides/integration-states#credentials-invalid).
   * - `INACTIVE`: The integration has stopped syncing as it's been manually set to inactive. You can [enable it again](../guides/integration-states#inactive) in the integration's page.
   */
  status: GetIntegrationsIntegrationIdPositiveResponseStatus;
  /**
   * The setup_status is used in conjunction with the filtering and field mapping features. If these are enabled in the connection flow, the integration will start in an "INCOMPLETE" state and move to "COMPLETE" once all steps are finished.
   *
   * @remarks
   *
   * - `INCOMPLETE`: Setup is still in progress. Some steps aren’t finished, so no data is available yet. Syncs only run as needed for setup.
   * - `FINAL_SYNC_PENDING`: Setup is complete, and the final sync is running. Data will be available after this sync is done.
   * - `COMPLETED`: Setup is fully finished, and the integration is ready to use.
   */
  setup_status: GetIntegrationsIntegrationIdPositiveResponseSetupStatus;
  end_user: GetIntegrationsIntegrationIdPositiveResponseEndUser;
  scope_config: ScopeConfig;
  /**
   * YYYY-MM-DDTHH:mm:ss.sssZ
   */
  created_at: Date;
  beta: boolean;
  read_models: Array<GetIntegrationsIntegrationIdPositiveResponseReadModel>;
};

export type GetIntegrationsIntegrationIdPositiveResponse = {
  status: "success";
  data: GetIntegrationsIntegrationIdPositiveResponseData;
};

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseTool$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    label: z.string(),
    internal_label: z.nullable(z.string()),
    logo_url: z.string(),
    icon_url: z.string(),
  });

export function getIntegrationsIntegrationIdPositiveResponseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseTool' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseCategory$inboundSchema:
  z.ZodNativeEnum<typeof GetIntegrationsIntegrationIdPositiveResponseCategory> =
    z.nativeEnum(GetIntegrationsIntegrationIdPositiveResponseCategory);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof GetIntegrationsIntegrationIdPositiveResponseStatus> = z
    .nativeEnum(GetIntegrationsIntegrationIdPositiveResponseStatus);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseSetupStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseSetupStatus
  > = z.nativeEnum(GetIntegrationsIntegrationIdPositiveResponseSetupStatus);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseEndUser$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseEndUser,
    z.ZodTypeDef,
    unknown
  > = z.object({
    organization_name: z.string(),
    creator_email: z.nullable(z.string()),
    origin_id: z.nullable(z.string()),
  });

export function getIntegrationsIntegrationIdPositiveResponseEndUserFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseEndUser,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseEndUser$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseEndUser' from JSON`,
  );
}

/** @internal */
export const ScopeConfig$inboundSchema: z.ZodType<
  ScopeConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.nullable(z.string()),
});

export function scopeConfigFromJSON(
  jsonString: string,
): SafeParseResult<ScopeConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScopeConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScopeConfig' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseCoverageStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseCoverageStatus
  > = z.nativeEnum(GetIntegrationsIntegrationIdPositiveResponseCoverageStatus);

/** @internal */
export const ScopeConfigSetting$inboundSchema: z.ZodNativeEnum<
  typeof ScopeConfigSetting
> = z.nativeEnum(ScopeConfigSetting);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus
  > = z.nativeEnum(
    GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus,
  );

/** @internal */
export const FieldScopeConfigSetting$inboundSchema: z.ZodNativeEnum<
  typeof FieldScopeConfigSetting
> = z.nativeEnum(FieldScopeConfigSetting);

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseField$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseField,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    is_available: z.boolean(),
    coverage_status:
      GetIntegrationsIntegrationIdPositiveResponseFieldCoverageStatus$inboundSchema,
    scope_config_setting: FieldScopeConfigSetting$inboundSchema,
    opted_out_by_customer: z.boolean(),
  });

export function getIntegrationsIntegrationIdPositiveResponseFieldFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseField,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseField$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseField' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseReadModel$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseReadModel,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    label: z.string(),
    is_available: z.boolean(),
    coverage_status:
      GetIntegrationsIntegrationIdPositiveResponseCoverageStatus$inboundSchema,
    scope_config_setting: ScopeConfigSetting$inboundSchema,
    opted_out_by_customer: z.boolean(),
    fields: z.array(
      z.lazy(() =>
        GetIntegrationsIntegrationIdPositiveResponseField$inboundSchema
      ),
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseReadModelFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseReadModel,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseReadModel$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseReadModel' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponseData$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponseData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    tool: z.lazy(() =>
      GetIntegrationsIntegrationIdPositiveResponseTool$inboundSchema
    ),
    category:
      GetIntegrationsIntegrationIdPositiveResponseCategory$inboundSchema,
    status: GetIntegrationsIntegrationIdPositiveResponseStatus$inboundSchema,
    setup_status:
      GetIntegrationsIntegrationIdPositiveResponseSetupStatus$inboundSchema,
    end_user: z.lazy(() =>
      GetIntegrationsIntegrationIdPositiveResponseEndUser$inboundSchema
    ),
    scope_config: z.lazy(() => ScopeConfig$inboundSchema),
    created_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    beta: z.boolean(),
    read_models: z.array(
      z.lazy(() =>
        GetIntegrationsIntegrationIdPositiveResponseReadModel$inboundSchema
      ),
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponseData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponseData$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetIntegrationsIntegrationIdPositiveResponse$inboundSchema:
  z.ZodType<
    GetIntegrationsIntegrationIdPositiveResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    status: z.literal("success"),
    data: z.lazy(() =>
      GetIntegrationsIntegrationIdPositiveResponseData$inboundSchema
    ),
  });

export function getIntegrationsIntegrationIdPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  GetIntegrationsIntegrationIdPositiveResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetIntegrationsIntegrationIdPositiveResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetIntegrationsIntegrationIdPositiveResponse' from JSON`,
  );
}
