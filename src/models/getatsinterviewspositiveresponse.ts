/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Location of the interview.
 */
export type GetAtsInterviewsPositiveResponseLocation = {
  city?: string | null | undefined;
  /**
   * Contains the ISO2 country code if possible. If not, it contains the original value.
   */
  country?: string | null | undefined;
  /**
   * If we have address data, this is filled with the raw address string.
   */
  raw?: string | null | undefined;
  state?: string | null | undefined;
  /**
   * If we can parse the address data, this field contains the first part of the street information.
   */
  street_1?: string | null | undefined;
  street_2?: string | null | undefined;
  zip_code?: string | null | undefined;
};

export type User = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * First name of the user.
   */
  first_name: string | null;
  /**
   * Last name of the user.
   */
  last_name: string | null;
  /**
   * Email of the user. If the email address is invalid, it will be set to null.
   */
  email?: string | null | undefined;
};

/**
 * Parsed status of the application. If Kombo identifies that the application was accepted and the candidate hired, it will be `HIRED`. If the application was rejected or the candidate declined, it will be `DECLINED`. If the application is still in process, it will be `PENDING`.
 *
 * @remarks
 * Kombo will always try to deliver this information as reliably as possible.
 */
export const GetAtsInterviewsPositiveResponseOutcome = {
  Pending: "PENDING",
  Hired: "HIRED",
  Declined: "DECLINED",
} as const;
/**
 * Parsed status of the application. If Kombo identifies that the application was accepted and the candidate hired, it will be `HIRED`. If the application was rejected or the candidate declined, it will be `DECLINED`. If the application is still in process, it will be `PENDING`.
 *
 * @remarks
 * Kombo will always try to deliver this information as reliably as possible.
 */
export type GetAtsInterviewsPositiveResponseOutcome = ClosedEnum<
  typeof GetAtsInterviewsPositiveResponseOutcome
>;

export type GetAtsInterviewsPositiveResponseEmailAddress = {
  email_address?: string | null | undefined;
  /**
   * Kombo exposes type information through this field. If we don't get any information from the tool, we will set this to `null`.
   */
  type: string | null;
};

export type GetAtsInterviewsPositiveResponseCandidate = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * First name of the candidate.
   */
  first_name: string | null;
  /**
   * Last name of the candidate.
   */
  last_name: string | null;
  /**
   * A list of email addresses of the candidate with an optional type. If an email address is invalid, it will be filtered out.
   */
  email_addresses?:
    | Array<GetAtsInterviewsPositiveResponseEmailAddress>
    | null
    | undefined;
};

export type GetAtsInterviewsPositiveResponseJob = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string;
  /**
   * Title of the job.
   */
  name: string | null;
};

export type GetAtsInterviewsPositiveResponseApplication = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * Parsed status of the application. If Kombo identifies that the application was accepted and the candidate hired, it will be `HIRED`. If the application was rejected or the candidate declined, it will be `DECLINED`. If the application is still in process, it will be `PENDING`.
   *
   * @remarks
   * Kombo will always try to deliver this information as reliably as possible.
   */
  outcome: GetAtsInterviewsPositiveResponseOutcome | null;
  /**
   * Reason for the rejection of the candidate.
   */
  rejection_reason_name: string | null;
  candidate: GetAtsInterviewsPositiveResponseCandidate | null;
  job: GetAtsInterviewsPositiveResponseJob | null;
};

export type GetAtsInterviewsPositiveResponseResult = {
  /**
   * The globally unique ID of this object generated by Kombo. We recommend using this as a stable primary key for syncing.
   */
  id: string;
  /**
   * The raw ID of the object in the remote system. We don't recommend using this as a primary key on your side as it might sometimes be compromised of multiple identifiers if a system doesn't provide a clear primary key.
   */
  remote_id: string | null;
  /**
   * The title of the interview.
   */
  title: string | null;
  /**
   * The start time of the interview.
   */
  starting_at: Date | null;
  /**
   * The end time of the interview.
   */
  ending_at: Date | null;
  /**
   * Location of the interview.
   */
  location?: GetAtsInterviewsPositiveResponseLocation | null | undefined;
  /**
   * The Kombo ID of the application this interview belongs to. The ID can be used to retrieve the application from the `get applications` endpoint.
   */
  application_id: string | null;
  /**
   * If a system specifies to which stage this interview belongs to, this field will be the Kombo ID of the application stage. The ID can be used to retrieve the stage from the `get application stages` endpoint.
   */
  stage_id: string | null;
  /**
   * Whether the interview was canceled or not. If we have no information, this field will be `null`.
   */
  canceled: boolean | null;
  /**
   * The date and time the object was created in the remote system.
   */
  remote_created_at: Date | null;
  /**
   * A timestamp retrieved from the remote system, describing when the resource was last updated.
   */
  remote_updated_at: Date | null;
  /**
   * The timestamp when this specific record was last modified. This field only updates when properties directly on this record change, NOT when related or nested models change. For filtering that considers nested data changes, use the `updated_after` parameter which will return records when either the record itself OR its related models have been updated.
   */
  changed_at: Date;
  /**
   * The date and time the object was deleted in the remote system. Objects are automatically marked as deleted when Kombo can't retrieve them from the remote system anymore. Kombo will also anonymize entries 14 days after they disappear.
   */
  remote_deleted_at: Date | null;
  users: Array<User>;
  application: GetAtsInterviewsPositiveResponseApplication | null;
};

export type GetAtsInterviewsPositiveResponseData = {
  /**
   * Cursor string that can be passed to the `cursor` query parameter to get the next page. If this is `null`, then there are no more pages.
   */
  next: string | null;
  results: Array<GetAtsInterviewsPositiveResponseResult>;
};

export type GetAtsInterviewsPositiveResponse = {
  status: "success";
  data: GetAtsInterviewsPositiveResponseData;
};

/** @internal */
export const GetAtsInterviewsPositiveResponseLocation$inboundSchema: z.ZodType<
  GetAtsInterviewsPositiveResponseLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  city: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  raw: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  street_1: z.nullable(z.string()).optional(),
  street_2: z.nullable(z.string()).optional(),
  zip_code: z.nullable(z.string()).optional(),
});

export function getAtsInterviewsPositiveResponseLocationFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAtsInterviewsPositiveResponseLocation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseLocation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAtsInterviewsPositiveResponseLocation' from JSON`,
  );
}

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    remote_id: z.nullable(z.string()),
    first_name: z.nullable(z.string()),
    last_name: z.nullable(z.string()),
    email: z.nullable(z.string()).optional(),
  });

export function userFromJSON(
  jsonString: string,
): SafeParseResult<User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'User' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponseOutcome$inboundSchema:
  z.ZodNativeEnum<typeof GetAtsInterviewsPositiveResponseOutcome> = z
    .nativeEnum(GetAtsInterviewsPositiveResponseOutcome);

/** @internal */
export const GetAtsInterviewsPositiveResponseEmailAddress$inboundSchema:
  z.ZodType<
    GetAtsInterviewsPositiveResponseEmailAddress,
    z.ZodTypeDef,
    unknown
  > = z.object({
    email_address: z.nullable(z.string()).optional(),
    type: z.nullable(z.string()),
  });

export function getAtsInterviewsPositiveResponseEmailAddressFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAtsInterviewsPositiveResponseEmailAddress,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseEmailAddress$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAtsInterviewsPositiveResponseEmailAddress' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponseCandidate$inboundSchema: z.ZodType<
  GetAtsInterviewsPositiveResponseCandidate,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  first_name: z.nullable(z.string()),
  last_name: z.nullable(z.string()),
  email_addresses: z.nullable(
    z.array(z.lazy(() =>
      GetAtsInterviewsPositiveResponseEmailAddress$inboundSchema
    )),
  ).optional(),
});

export function getAtsInterviewsPositiveResponseCandidateFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAtsInterviewsPositiveResponseCandidate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseCandidate$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAtsInterviewsPositiveResponseCandidate' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponseJob$inboundSchema: z.ZodType<
  GetAtsInterviewsPositiveResponseJob,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.string(),
  name: z.nullable(z.string()),
});

export function getAtsInterviewsPositiveResponseJobFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsInterviewsPositiveResponseJob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseJob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsInterviewsPositiveResponseJob' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponseApplication$inboundSchema:
  z.ZodType<
    GetAtsInterviewsPositiveResponseApplication,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    remote_id: z.nullable(z.string()),
    outcome: z.nullable(GetAtsInterviewsPositiveResponseOutcome$inboundSchema),
    rejection_reason_name: z.nullable(z.string()),
    candidate: z.nullable(
      z.lazy(() => GetAtsInterviewsPositiveResponseCandidate$inboundSchema),
    ),
    job: z.nullable(
      z.lazy(() => GetAtsInterviewsPositiveResponseJob$inboundSchema),
    ),
  });

export function getAtsInterviewsPositiveResponseApplicationFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAtsInterviewsPositiveResponseApplication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseApplication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAtsInterviewsPositiveResponseApplication' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponseResult$inboundSchema: z.ZodType<
  GetAtsInterviewsPositiveResponseResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  remote_id: z.nullable(z.string()),
  title: z.nullable(z.string()),
  starting_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  ending_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  location: z.nullable(
    z.lazy(() => GetAtsInterviewsPositiveResponseLocation$inboundSchema),
  ).optional(),
  application_id: z.nullable(z.string()),
  stage_id: z.nullable(z.string()),
  canceled: z.nullable(z.boolean()),
  remote_created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  remote_updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  changed_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  remote_deleted_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ),
  users: z.array(z.lazy(() => User$inboundSchema)),
  application: z.nullable(
    z.lazy(() => GetAtsInterviewsPositiveResponseApplication$inboundSchema),
  ),
});

export function getAtsInterviewsPositiveResponseResultFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsInterviewsPositiveResponseResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsInterviewsPositiveResponseResult' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponseData$inboundSchema: z.ZodType<
  GetAtsInterviewsPositiveResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  next: z.nullable(z.string()),
  results: z.array(
    z.lazy(() => GetAtsInterviewsPositiveResponseResult$inboundSchema),
  ),
});

export function getAtsInterviewsPositiveResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsInterviewsPositiveResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAtsInterviewsPositiveResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsInterviewsPositiveResponseData' from JSON`,
  );
}

/** @internal */
export const GetAtsInterviewsPositiveResponse$inboundSchema: z.ZodType<
  GetAtsInterviewsPositiveResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: z.literal("success"),
  data: z.lazy(() => GetAtsInterviewsPositiveResponseData$inboundSchema),
});

export function getAtsInterviewsPositiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetAtsInterviewsPositiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAtsInterviewsPositiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAtsInterviewsPositiveResponse' from JSON`,
  );
}
