/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { KomboCore } from "../core.js";
import { encodeJSON } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { KomboError } from "../models/errors/komboerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create connection link
 *
 * @remarks
 * Generate a unique link that allows your user to enter the embedded Kombo Connect flow.
 *
 * > Check out [our full guide](/connect/embedded-flow) for more details about implementing the connection flow into your app.
 *
 * > Kombo will not deduplicate integrations for you that are created with this endpoint. You are responsible for keeping track of integrations in your system and prevent customers from connecting the same tool again. Use the [reconnection link](/v1/post-integrations-integration-id-relink) endpoint if you want a customer to update their credentials.
 *
 * ### Example Request Body
 *
 * ```json
 * {
 *   "end_user_email": "test@example.com",
 *   "end_user_organization_name": "Test Inc.",
 *   "integration_category": "HRIS",
 *   "integration_tool": "personio",
 *   "end_user_origin_id": "123",
 *   "language": "en",
 *   "link_type": "EMBEDDED"
 * }
 * ```
 */
export function connectCreateConnectionLink(
  client: KomboCore,
  request: models.PostConnectCreateLinkRequestBody,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.PostConnectCreateLinkPositiveResponse,
    | errors.KomboGeneralError
    | KomboError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: KomboCore,
  request: models.PostConnectCreateLinkRequestBody,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.PostConnectCreateLinkPositiveResponse,
      | errors.KomboGeneralError
      | KomboError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      models.PostConnectCreateLinkRequestBody$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });

  const path = pathToFunc("/connect/create-link")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.api_key);
  const securityInput = secConfig == null ? {} : { api_key: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    base_url: options?.server_url ?? client._baseURL ?? "",
    operation_id: "PostConnectCreateLink",
    o_auth2_scopes: null,

    resolved_security: requestSecurity,

    security_source: client._options.api_key,
    retry_config: options?.retries
      || client._options.retry_config
      || { strategy: "none" },
    retry_codes: options?.retry_codes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.server_url,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.user_agent,
    timeout_ms: options?.timeout_ms || client._options.timeout_ms || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["default"],
    retryConfig: context.retry_config,
    retryCodes: context.retry_codes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.PostConnectCreateLinkPositiveResponse,
    | errors.KomboGeneralError
    | KomboError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, models.PostConnectCreateLinkPositiveResponse$inboundSchema),
    M.jsonErr("default", errors.KomboGeneralError$inboundSchema),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
